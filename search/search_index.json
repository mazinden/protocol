{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rarible Protocol \u00b6 Rarible Multichain Protocol is a blockchain-agnostic and decentralized tool to query, issue, and trade NFTs. Learn more about Protocol usage \u00b6 Protocol Overview Explore references and resources \u00b6 API Reference Multichain SDK Get started with Multichain SDK basics and create the first application \u00b6 Quick Start React Example App Take community support and additional information \u00b6 Community and resources","title":"Home"},{"location":"#rarible-protocol","text":"Rarible Multichain Protocol is a blockchain-agnostic and decentralized tool to query, issue, and trade NFTs.","title":"Rarible Protocol"},{"location":"#learn-more-about-protocol-usage","text":"Protocol Overview","title":"Learn more about Protocol usage"},{"location":"#explore-references-and-resources","text":"API Reference Multichain SDK","title":"Explore references and resources"},{"location":"#get-started-with-multichain-sdk-basics-and-create-the-first-application","text":"Quick Start React Example App","title":"Get started with Multichain SDK basics and create the first application"},{"location":"#take-community-support-and-additional-information","text":"Community and resources","title":"Take community support and additional information"},{"location":"LICENSE/","text":"GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands show w' and show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/ . The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html .","title":"LICENSE"},{"location":"MIT-LICENSE/","text":"Copyright (c) 2021, Rarible DAO Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT LICENSE"},{"location":"api-reference/","text":"API Reference \u00b6 Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. ethereum-api.rarible.org or any testnet equivalent is only compatible with the ethereum blockchain. Mainnet \u00b6 Base URL Network https://api.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api.rarible.org/v0.1/doc Ethereum https://flow-api.rarible.com/v0.1/doc Flow https://rarible-api-mainnet.functori.com/v0.1 Tezos Staging \u00b6 Base URL Network Testnet https://api-staging.rarible.org/v0.1/doc Rarible Protocol Rinkeby https://ethereum-api-staging.rarible.org/v0.1/doc Ethereum Rinkeby https://flow-api-staging.rarible.com/v0.1/doc Flow Rinkeby Development \u00b6 Base URL Network Testnet https://api-dev.rarible.org/v0.1/doc Rarible Protocol Ropsten https://ethereum-api-dev.rarible.org/v0.1/doc Ethereum Ropsten http://flow-api-dev.rarible.com/v0.1/doc Flow Ropsten https://rarible-api.functori.com/v0.1 Tezos Hangzhou e2e \u00b6 Base URL Network https://api-e2e.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-e2e.rarible.org/v0.1/doc Ethereum","title":"API"},{"location":"api-reference/#api-reference","text":"Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. ethereum-api.rarible.org or any testnet equivalent is only compatible with the ethereum blockchain.","title":"API Reference"},{"location":"api-reference/#mainnet","text":"Base URL Network https://api.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api.rarible.org/v0.1/doc Ethereum https://flow-api.rarible.com/v0.1/doc Flow https://rarible-api-mainnet.functori.com/v0.1 Tezos","title":"Mainnet"},{"location":"api-reference/#staging","text":"Base URL Network Testnet https://api-staging.rarible.org/v0.1/doc Rarible Protocol Rinkeby https://ethereum-api-staging.rarible.org/v0.1/doc Ethereum Rinkeby https://flow-api-staging.rarible.com/v0.1/doc Flow Rinkeby","title":"Staging"},{"location":"api-reference/#development","text":"Base URL Network Testnet https://api-dev.rarible.org/v0.1/doc Rarible Protocol Ropsten https://ethereum-api-dev.rarible.org/v0.1/doc Ethereum Ropsten http://flow-api-dev.rarible.com/v0.1/doc Flow Ropsten https://rarible-api.functori.com/v0.1 Tezos Hangzhou","title":"Development"},{"location":"api-reference/#e2e","text":"Base URL Network https://api-e2e.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-e2e.rarible.org/v0.1/doc Ethereum","title":"e2e"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version. Do I need tokenId to lazy minting NFT through SDK? \u00b6 Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint. How to connect Metamask with SDK? \u00b6 Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK. Why the price in the sell order can't be updated to a higher value? \u00b6 That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message. What does the union-service repo do? \u00b6 Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them. What kind of fee model does the protocol use? \u00b6 See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs. What is \"deploy\" in the SDK used for? \u00b6 It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version.","title":"Frequently Asked Questions"},{"location":"faq/#do-i-need-tokenid-to-lazy-minting-nft-through-sdk","text":"Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint.","title":"Do I need tokenId to lazy minting NFT through SDK?"},{"location":"faq/#how-to-connect-metamask-with-sdk","text":"Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK.","title":"How to connect Metamask with SDK?"},{"location":"faq/#why-the-price-in-the-sell-order-cant-be-updated-to-a-higher-value","text":"That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message.","title":"Why the price in the sell order can't be updated to a higher value?"},{"location":"faq/#what-does-the-union-service-repo-do","text":"Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them.","title":"What does the union-service repo do?"},{"location":"faq/#what-kind-of-fee-model-does-the-protocol-use","text":"See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs.","title":"What kind of fee model does the protocol use?"},{"location":"faq/#what-is-deploy-in-the-sdk-used-for","text":"It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"What is \"deploy\" in the SDK used for?"},{"location":"union-sdk/","text":"Rarible Protocol SDK \u00b6 Overview \u00b6 Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets (ERC721, ERC1155) and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. Currently, Rarible Protocol SDK supports following blockchains: Ethereum (mainnet, ropsten, rinkeby) Flow (mainnet, ropsten, rinkeby) Tezos (mainnet, granada) Installation \u00b6 Using SDK should be fast, easy and intuitive \u2014 that's for what we're aiming for. Below you can see an example of implementation. Install required packages using npm or yarn. For most of the projects, apart of the Rarible SDK we'll also need web3. npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3 Create a project with the JS framework of your choice (we'll be using NextJS here). In order to properly set up the Rarible SDK we need to follow some standard web3 practices. Grab ethereum object out of the global window object. Use it to create a new instance of Web3. Create new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in previous step. In code it looks like that (using TypeScript): // Imports import Web3 from \"web3\" ; import { createRaribleSdk } from \"@rarible/sdk\" ; import { EthereumWallet } from \"@rarible/sdk-wallet\" ; // Code const { ethereum } = window as any ; const web3 = new Web3 ( ethereum ); const ethWallet = new EthereumWallet ( ethereum ); const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ); RaribleSdk object is ready for use. Few more things: If you're wondering what's \"staging\" in createRaribleSdk it's environment parameter. We have four options here: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected. Metamask integration with Rarible \u00b6 In the previous chapter we talked about how we can initalize Rarible SDK, but it was more theoretical. In actual development, in almost any dApp we'd like to identify users through a wallet address they are using. At first sight you may think that it's not really related to the Rarible Protocol, but a correct set up is required to use the SDK smoothly and easily. In this chapter, I will guide you through this process (it's a proposition of implementation, not the only correct way, but widely used). Once you get the idea you can work with that however you'd like. Below you can find a list of steps that should be taken after the \"Connect Metamask\" button is clicked. Identify if user has a blockchain provider (i.e. if he has Metamask installed) const getProvider = () => { // 1. Getting ethereum object out of global JS object if (( window as any ). ethereum ) { const { ethereum } = window as any ; return ethereum ; } // 2. If ethereum property does not exist it means that user needs to install Metamask else { alert ( \"Please install Metamask\" ); } }; const provider = getProvider (); Request and get metamask accounts - metamask should pop up in this step, to authorize the app const connect = async () => { if ( ! provider ) { alert ( \"No provider found!\" ); } else { // 1. Making metamask request await provider . request ({ method : \"eth_requestAccounts\" }); // 2. Getting currently connected accounts const accounts = await provider . request ({ method : \"eth_accounts\" }); if ( accounts . length > 0 ) { // First item is always currently used account setAccount ( accounts [ 0 ]); } // Setting event listener on whenever user has changed account provider . on ( \"accountsChanged\" , ( accs : any ) => { const [ currentAccount ] = accs ; setAccount ( currentAccount ); }); } }; Prepare EthereumWallet for RaribleSdk const wallet = () => { // 1. Check if provider and currentAccount is successfully set if ( provider && currentAccount ) { return new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( provider ), from : currentAccount }) ); } else { return undefined ; } }; Create RaribleSDK // 1. \"env\" parameter is one of \"prod\" | \"dev\" | \"staging\" | \"e2e\" mentioned earlier const sdk = ( env : string ) => { if ( wallet ) { return createRaribleSdk ( wallet , env as any ); } else { return undefined ; } }; Now we have the working example with Metamask connected and Rarible SDK configured. Here you can find code used in example in broader picture. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Overview"},{"location":"union-sdk/#rarible-protocol-sdk","text":"","title":"Rarible Protocol SDK"},{"location":"union-sdk/#overview","text":"Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets (ERC721, ERC1155) and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. Currently, Rarible Protocol SDK supports following blockchains: Ethereum (mainnet, ropsten, rinkeby) Flow (mainnet, ropsten, rinkeby) Tezos (mainnet, granada)","title":"Overview"},{"location":"union-sdk/#installation","text":"Using SDK should be fast, easy and intuitive \u2014 that's for what we're aiming for. Below you can see an example of implementation. Install required packages using npm or yarn. For most of the projects, apart of the Rarible SDK we'll also need web3. npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3 Create a project with the JS framework of your choice (we'll be using NextJS here). In order to properly set up the Rarible SDK we need to follow some standard web3 practices. Grab ethereum object out of the global window object. Use it to create a new instance of Web3. Create new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in previous step. In code it looks like that (using TypeScript): // Imports import Web3 from \"web3\" ; import { createRaribleSdk } from \"@rarible/sdk\" ; import { EthereumWallet } from \"@rarible/sdk-wallet\" ; // Code const { ethereum } = window as any ; const web3 = new Web3 ( ethereum ); const ethWallet = new EthereumWallet ( ethereum ); const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ); RaribleSdk object is ready for use. Few more things: If you're wondering what's \"staging\" in createRaribleSdk it's environment parameter. We have four options here: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected.","title":"Installation"},{"location":"union-sdk/#metamask-integration-with-rarible","text":"In the previous chapter we talked about how we can initalize Rarible SDK, but it was more theoretical. In actual development, in almost any dApp we'd like to identify users through a wallet address they are using. At first sight you may think that it's not really related to the Rarible Protocol, but a correct set up is required to use the SDK smoothly and easily. In this chapter, I will guide you through this process (it's a proposition of implementation, not the only correct way, but widely used). Once you get the idea you can work with that however you'd like. Below you can find a list of steps that should be taken after the \"Connect Metamask\" button is clicked. Identify if user has a blockchain provider (i.e. if he has Metamask installed) const getProvider = () => { // 1. Getting ethereum object out of global JS object if (( window as any ). ethereum ) { const { ethereum } = window as any ; return ethereum ; } // 2. If ethereum property does not exist it means that user needs to install Metamask else { alert ( \"Please install Metamask\" ); } }; const provider = getProvider (); Request and get metamask accounts - metamask should pop up in this step, to authorize the app const connect = async () => { if ( ! provider ) { alert ( \"No provider found!\" ); } else { // 1. Making metamask request await provider . request ({ method : \"eth_requestAccounts\" }); // 2. Getting currently connected accounts const accounts = await provider . request ({ method : \"eth_accounts\" }); if ( accounts . length > 0 ) { // First item is always currently used account setAccount ( accounts [ 0 ]); } // Setting event listener on whenever user has changed account provider . on ( \"accountsChanged\" , ( accs : any ) => { const [ currentAccount ] = accs ; setAccount ( currentAccount ); }); } }; Prepare EthereumWallet for RaribleSdk const wallet = () => { // 1. Check if provider and currentAccount is successfully set if ( provider && currentAccount ) { return new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( provider ), from : currentAccount }) ); } else { return undefined ; } }; Create RaribleSDK // 1. \"env\" parameter is one of \"prod\" | \"dev\" | \"staging\" | \"e2e\" mentioned earlier const sdk = ( env : string ) => { if ( wallet ) { return createRaribleSdk ( wallet , env as any ); } else { return undefined ; } }; Now we have the working example with Metamask connected and Rarible SDK configured. Here you can find code used in example in broader picture. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Metamask integration with Rarible"},{"location":"ethereum/contract-addresses/","text":"Contract Addresses \u00b6 Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet. Mainnet \u00b6 Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C \u2197 Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197 ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197 ERC1155 Token Factory 0x81243681078bEE8e251D02Ee6872b1EAa6DD982A \u2197 Rinkeby \u00b6 Is known to usually be more reliable than Ropsten. Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 \u2197 Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197 External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197 ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197 ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197 Ropsten \u00b6 Is known to be less reliable. Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 \u2197 Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197 External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197 NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197 ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197 ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#contract-addresses","text":"Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet.","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#mainnet","text":"Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C \u2197 Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197 ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197 ERC1155 Token Factory 0x81243681078bEE8e251D02Ee6872b1EAa6DD982A \u2197","title":"Mainnet"},{"location":"ethereum/contract-addresses/#rinkeby","text":"Is known to usually be more reliable than Ropsten. Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 \u2197 Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197 External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197 ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197 ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197","title":"Rinkeby"},{"location":"ethereum/contract-addresses/#ropsten","text":"Is known to be less reliable. Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 \u2197 Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197 External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197 NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197 ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197 ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197","title":"Ropsten"},{"location":"ethereum/ethereum-overview/","text":"Rarible Protocol Ethereum \u00b6 Overview \u00b6 Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK. Main features: Decentralized Exchange Open Source Indexer Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting Ability to share Fees Royalties Support Public Order Book Smart Contracts \u00b6 Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met. To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo. API Reference \u00b6 Use these base URLs to access API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/v0.1/doc Mainnet 1 https://ethereum-api-staging.rarible.org/v0.1/doc Rinkeby 4 https://ethereum-api-dev.rarible.org/v0.1/doc Ropsten 3 https://ethereum-api-e2e.rarible.org/v0.1/doc - - See the page API and Indexer to see how to work with the API. For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub. SDK \u00b6 Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol. Main features: Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens Create Sell Orders Create and accept Bid Buy tokens Transfer tokens Burn tokens For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Ethereum Overview"},{"location":"ethereum/ethereum-overview/#rarible-protocol-ethereum","text":"","title":"Rarible Protocol Ethereum"},{"location":"ethereum/ethereum-overview/#overview","text":"Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK. Main features: Decentralized Exchange Open Source Indexer Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting Ability to share Fees Royalties Support Public Order Book","title":"Overview"},{"location":"ethereum/ethereum-overview/#smart-contracts","text":"Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met. To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo.","title":"Smart Contracts"},{"location":"ethereum/ethereum-overview/#api-reference","text":"Use these base URLs to access API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/v0.1/doc Mainnet 1 https://ethereum-api-staging.rarible.org/v0.1/doc Rinkeby 4 https://ethereum-api-dev.rarible.org/v0.1/doc Ropsten 3 https://ethereum-api-e2e.rarible.org/v0.1/doc - - See the page API and Indexer to see how to work with the API. For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub.","title":"API Reference"},{"location":"ethereum/ethereum-overview/#sdk","text":"Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol. Main features: Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens Create Sell Orders Create and accept Bid Buy tokens Transfer tokens Burn tokens For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"SDK"},{"location":"ethereum/api/create-lazy-minting/","text":"Using Lazy Minting \u00b6 To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller . mintNftAsset \u00b6 Creates a Lazy Minted NFT token. https://ethereum-api-staging.rarible.org/v0.1/nft/mints Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\ --header 'content-type: application/json' \\ --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}' Request parameters: @typerequired \u2014 token type ERC721 or ERC1155 supply \u2014 the total number of tokens for Mint. Only for ERC-1155 contract \u2014 address of the smart contract tokenId \u2014 token ID uri \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction. Response example (status 200): { \"id\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T15:37:03.610Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Violence Token\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 400 , \"height\" : 400 } } } } } Response parameters: id \u2014 item ID, has the format ${contract}:${tokenId} contract \u2014 address of the smart contract tokenId \u2014 token ID creators \u2014 array of information about creators supply \u2014 number of tokens created lazysupply \u2014 the number of Lazy Minting tokens created owners \u2014 array of information about token owners royalties \u2014 an array of information about royalties date \u2014 date of token creation pending \u2014 whether the item is incomplete. For example, it is in the status TRANSFER deleted \u2014 is the order deleted meta \u2014 meta information about the item","title":"Create Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#using-lazy-minting","text":"To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller .","title":"Using Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#mintnftasset","text":"Creates a Lazy Minted NFT token. https://ethereum-api-staging.rarible.org/v0.1/nft/mints Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\ --header 'content-type: application/json' \\ --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}' Request parameters: @typerequired \u2014 token type ERC721 or ERC1155 supply \u2014 the total number of tokens for Mint. Only for ERC-1155 contract \u2014 address of the smart contract tokenId \u2014 token ID uri \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction. Response example (status 200): { \"id\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T15:37:03.610Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Violence Token\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 400 , \"height\" : 400 } } } } } Response parameters: id \u2014 item ID, has the format ${contract}:${tokenId} contract \u2014 address of the smart contract tokenId \u2014 token ID creators \u2014 array of information about creators supply \u2014 number of tokens created lazysupply \u2014 the number of Lazy Minting tokens created owners \u2014 array of information about token owners royalties \u2014 an array of information about royalties date \u2014 date of token creation pending \u2014 whether the item is incomplete. For example, it is in the status TRANSFER deleted \u2014 is the order deleted meta \u2014 meta information about the item","title":"mintNftAsset"},{"location":"ethereum/api/create-orders/","text":"Create Orders \u00b6 To create an order, use the upsertOrder method in order-controller . upsertOrder \u00b6 Creates or updates an Order. https://ethereum-api.rarible.org/v0.1/order/orders Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\ --header 'content-type: application/json' \\ --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}' Request parameters: type \u2014 order type RARIBLE_V1 or RARIBLE_V2 data \u2014 data for creating or updating the order. The required fields depend on order type maker \u2014 address of the order creator taker \u2014 address of the recipient of the order (optional) make \u2014 make the side of the order. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used signature \u2014 the digital signature of the order creator Response example (status 200): { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC721_LAZY\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"uri\" : \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\" ] }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ETH\" }, \"value\" : \"10000000000000000\" , \"valueDecimal\" : 0.01 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"1\" , \"makeStockValue\" : 1 , \"cancelled\" : false , \"salt\" : \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\" , \"signature\" : \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\" , \"createdAt\" : \"2021-11-23T15:37:13.158Z\" , \"lastUpdateAt\" : \"2021-11-23T15:37:13.158Z\" , \"pending\" : [], \"hash\" : \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\" , \"makeBalance\" : \"0\" , \"makePrice\" : 0.01 , \"makePriceUsd\" : 40.193574609729986 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:37:13.158Z\" , \"makeValue\" : 1 , \"takeValue\" : 0.01 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } Response parameters: type \u2014 order type RARIBLE_V1 , RARIBLE_V2 , OPEN_SEA_V1 or CRYPTO_PUNK data \u2014 information about order type, Fees, etc. maker \u2014 address of the order creator taker \u2014 address of the recipient of the order make \u2014 make the order side. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side fill \u2014 filling in data when matching fillvalue \u2014 data filling value start \u2014 the starting date of the order placement, from which the buyer can make a Bid end \u2014 the end date of the order placement before which the buyer can make a Bid makestock \u2014 how much is available for sale makestockvalue \u2014 the value of how much is available for sale cancelled \u2014 the order is canceled or not salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash signature \u2014 digital signature of the order creator createdAt \u2014 date of order creation lastupdateat \u2014 order update date pending \u2014 whether the order is incomplete. For example, it is in the status of CANCEL , ORDER_SIDE_MATCH or ON_CHAIN_ORDER hash \u2014 hash of the order makebalance \u2014 balance of the order creator makeprice \u2014 order price Takeprice \u2014 buyer's suggested price makepriceusd \u2014 order price in USD takepriceusd \u2014 price in USD suggested by the buyer pricehistory \u2014 history of price changes status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE or CANCELLED","title":"Create Orders"},{"location":"ethereum/api/create-orders/#create-orders","text":"To create an order, use the upsertOrder method in order-controller .","title":"Create Orders"},{"location":"ethereum/api/create-orders/#upsertorder","text":"Creates or updates an Order. https://ethereum-api.rarible.org/v0.1/order/orders Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\ --header 'content-type: application/json' \\ --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}' Request parameters: type \u2014 order type RARIBLE_V1 or RARIBLE_V2 data \u2014 data for creating or updating the order. The required fields depend on order type maker \u2014 address of the order creator taker \u2014 address of the recipient of the order (optional) make \u2014 make the side of the order. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used signature \u2014 the digital signature of the order creator Response example (status 200): { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC721_LAZY\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"uri\" : \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\" ] }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ETH\" }, \"value\" : \"10000000000000000\" , \"valueDecimal\" : 0.01 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"1\" , \"makeStockValue\" : 1 , \"cancelled\" : false , \"salt\" : \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\" , \"signature\" : \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\" , \"createdAt\" : \"2021-11-23T15:37:13.158Z\" , \"lastUpdateAt\" : \"2021-11-23T15:37:13.158Z\" , \"pending\" : [], \"hash\" : \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\" , \"makeBalance\" : \"0\" , \"makePrice\" : 0.01 , \"makePriceUsd\" : 40.193574609729986 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:37:13.158Z\" , \"makeValue\" : 1 , \"takeValue\" : 0.01 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } Response parameters: type \u2014 order type RARIBLE_V1 , RARIBLE_V2 , OPEN_SEA_V1 or CRYPTO_PUNK data \u2014 information about order type, Fees, etc. maker \u2014 address of the order creator taker \u2014 address of the recipient of the order make \u2014 make the order side. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side fill \u2014 filling in data when matching fillvalue \u2014 data filling value start \u2014 the starting date of the order placement, from which the buyer can make a Bid end \u2014 the end date of the order placement before which the buyer can make a Bid makestock \u2014 how much is available for sale makestockvalue \u2014 the value of how much is available for sale cancelled \u2014 the order is canceled or not salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash signature \u2014 digital signature of the order creator createdAt \u2014 date of order creation lastupdateat \u2014 order update date pending \u2014 whether the order is incomplete. For example, it is in the status of CANCEL , ORDER_SIDE_MATCH or ON_CHAIN_ORDER hash \u2014 hash of the order makebalance \u2014 balance of the order creator makeprice \u2014 order price Takeprice \u2014 buyer's suggested price makepriceusd \u2014 order price in USD takepriceusd \u2014 price in USD suggested by the buyer pricehistory \u2014 history of price changes status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE or CANCELLED","title":"upsertOrder"},{"location":"ethereum/api/ethereum-api-indexer/","text":"API and Indexer Overview \u00b6 The main functions of the API and indexer are: Follow the blockchain Handle read requests Process creation requests Architecture \u00b6 The Rarible Protocol Ethereum indexer consists of the following parts: NFT indexer \u2014 aggregates NFTs data ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances Order indexer \u2014 aggregates Orders data from different platforms Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain. Indexers generate events when the state changes. They are developed with Spring Framework and use these external services: MongoDB \u2014 main data storage Apache Kafka \u2014 event handling Controllers \u00b6 To create or modify NFTs and search information about them: nft-transaction-controller nft-lazy-mint-controller nft-activity-controller nft-ownership-controller nft-item-controller nft-collection-controller To create or modify orders and search information about them: order-signature-controller order-encode-controller order-controller order-transaction-controller order-activity-controller order-aggregation-controller nft-order-ownership-controller nft-order-item-controller nft-order-activity-controller nft-order-collection-controller Additional controllers: gateway-controller erc20-balance-controller erc20-token-controller lock-controller API usage Examples \u00b6 Search Items Search Orders Create Lazy Minting Create Orders","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#api-and-indexer-overview","text":"The main functions of the API and indexer are: Follow the blockchain Handle read requests Process creation requests","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#architecture","text":"The Rarible Protocol Ethereum indexer consists of the following parts: NFT indexer \u2014 aggregates NFTs data ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances Order indexer \u2014 aggregates Orders data from different platforms Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain. Indexers generate events when the state changes. They are developed with Spring Framework and use these external services: MongoDB \u2014 main data storage Apache Kafka \u2014 event handling","title":"Architecture"},{"location":"ethereum/api/ethereum-api-indexer/#controllers","text":"To create or modify NFTs and search information about them: nft-transaction-controller nft-lazy-mint-controller nft-activity-controller nft-ownership-controller nft-item-controller nft-collection-controller To create or modify orders and search information about them: order-signature-controller order-encode-controller order-controller order-transaction-controller order-activity-controller order-aggregation-controller nft-order-ownership-controller nft-order-item-controller nft-order-activity-controller nft-order-collection-controller Additional controllers: gateway-controller erc20-balance-controller erc20-token-controller lock-controller","title":"Controllers"},{"location":"ethereum/api/ethereum-api-indexer/#api-usage-examples","text":"Search Items Search Orders Create Lazy Minting Create Orders","title":"API usage Examples"},{"location":"ethereum/api/search-items/","text":"Search Items \u00b6 The main requests for working with Items relate to the nft-item-controller . Let's look at the example of getNftAllItems. getNftAllItems \u00b6 It will return all NFT items. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1' Request parameters: size \u2014 the number of items to be returned showDeleted \u2014 display deleted items or not lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms) lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms) continuation \u2014 continuation token from the previous response Response example (status 200): { \"total\" : 1 , \"continuation\" : \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\" , \"items\" : [ { \"id\" : \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"contract\" : \"0xf6793da657495ffeff9ee6350824910abc21356c\" , \"tokenId\" : \"58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"creators\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0x8108800667cb3859020c77f7643cedb794b44557\" ], \"royalties\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T14:31:04.204Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Rampows the Daltons\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 1792 , \"height\" : 1401 } } } } } ] } Response parameters: total \u2014 the number of items returned on request continuation \u2014 continuation token from the previous response items \u2014 list of found items & basic information about them","title":"Search Items"},{"location":"ethereum/api/search-items/#search-items","text":"The main requests for working with Items relate to the nft-item-controller . Let's look at the example of getNftAllItems.","title":"Search Items"},{"location":"ethereum/api/search-items/#getnftallitems","text":"It will return all NFT items. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1' Request parameters: size \u2014 the number of items to be returned showDeleted \u2014 display deleted items or not lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms) lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms) continuation \u2014 continuation token from the previous response Response example (status 200): { \"total\" : 1 , \"continuation\" : \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\" , \"items\" : [ { \"id\" : \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"contract\" : \"0xf6793da657495ffeff9ee6350824910abc21356c\" , \"tokenId\" : \"58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"creators\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0x8108800667cb3859020c77f7643cedb794b44557\" ], \"royalties\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T14:31:04.204Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Rampows the Daltons\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 1792 , \"height\" : 1401 } } } } } ] } Response parameters: total \u2014 the number of items returned on request continuation \u2014 continuation token from the previous response items \u2014 list of found items & basic information about them","title":"getNftAllItems"},{"location":"ethereum/api/search-orders/","text":"Search Orders \u00b6 The main requests for working with Orders refer to order-controller . Let's look at the example of getOrdersAllByStatus. getOrdersAllByStatus \u00b6 Returns all orders sorted by status. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&size=1&status=ACTIVE' Request parameters: sort \u2014 sort by last updated orders LAST_UPDATE_ASC , LAST_UPDATE_DESC size \u2014 number of orders to be returned continuation \u2014 continuation token from the previous response status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE , CANCELLED Response example (status 200): { \"orders\" : [ { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC20\" , \"contract\" : \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"260000000000000000\" , \"valueDecimal\" : 0.260000000000000000 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ERC721\" , \"contract\" : \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\" , \"tokenId\" : \"260\" }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"260000000000000000\" , \"makeStockValue\" : 0.260000000000000000 , \"cancelled\" : false , \"salt\" : \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\" , \"signature\" : \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\" , \"createdAt\" : \"2021-11-23T15:08:20.925Z\" , \"lastUpdateAt\" : \"2021-11-23T15:08:20.925Z\" , \"pending\" : [], \"hash\" : \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" , \"makeBalance\" : \"0\" , \"takePrice\" : 0.260000000000000000 , \"takePriceUsd\" : 1089.887807206807960000000000000000 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:08:20.925Z\" , \"makeValue\" : 0.260000000000000000 , \"takeValue\" : 1 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 250 } ] } } ], \"continuation\" : \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" } Response parameters: orders \u2014 list of found orders with basic information on them continuation \u2014 continuation token from the previous response","title":"Search Orders"},{"location":"ethereum/api/search-orders/#search-orders","text":"The main requests for working with Orders refer to order-controller . Let's look at the example of getOrdersAllByStatus.","title":"Search Orders"},{"location":"ethereum/api/search-orders/#getordersallbystatus","text":"Returns all orders sorted by status. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&size=1&status=ACTIVE' Request parameters: sort \u2014 sort by last updated orders LAST_UPDATE_ASC , LAST_UPDATE_DESC size \u2014 number of orders to be returned continuation \u2014 continuation token from the previous response status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE , CANCELLED Response example (status 200): { \"orders\" : [ { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC20\" , \"contract\" : \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"260000000000000000\" , \"valueDecimal\" : 0.260000000000000000 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ERC721\" , \"contract\" : \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\" , \"tokenId\" : \"260\" }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"260000000000000000\" , \"makeStockValue\" : 0.260000000000000000 , \"cancelled\" : false , \"salt\" : \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\" , \"signature\" : \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\" , \"createdAt\" : \"2021-11-23T15:08:20.925Z\" , \"lastUpdateAt\" : \"2021-11-23T15:08:20.925Z\" , \"pending\" : [], \"hash\" : \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" , \"makeBalance\" : \"0\" , \"takePrice\" : 0.260000000000000000 , \"takePriceUsd\" : 1089.887807206807960000000000000000 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:08:20.925Z\" , \"makeValue\" : 0.260000000000000000 , \"takeValue\" : 1 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 250 } ] } } ], \"continuation\" : \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" } Response parameters: orders \u2014 list of found orders with basic information on them continuation \u2014 continuation token from the previous response","title":"getOrdersAllByStatus"},{"location":"ethereum/assets/asset-discovery/","text":"Asset Discovery \u00b6 Search Items \u00b6 {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. Visit the next section on how to create a sell order !","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#asset-discovery","text":"","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#search-items","text":"{% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. Visit the next section on how to create a sell order !","title":"Search Items"},{"location":"ethereum/assets/creating-an-asset/","text":"Asset Creation \u00b6 Asset Introduction \u00b6 Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here. Ropsten \u00b6 Asset Contract ERC721 Etherscan link \u2197 \u00b6 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC1155 Etherscan link \u2197 \u00b6 0x6a94aC200342AC823F909F142a65232E2f052183 Rinkeby \u00b6 Asset Contract ERC721 Etherscan link \u2197 \u00b6 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC1155 Etherscan link \u2197 \u00b6 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Asset Types Explained \u00b6 ERC721 & ERC1155 \u00b6 With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC721 Lazy Minting \u00b6 If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 721 (Ropsten) \u00b6 Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC721 Standard Minting \u00b6 You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info Example \u00b6 async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } ERC1155 Overview \u00b6 mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC1155 Lazy Minting \u00b6 If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 1155 (Ropsten) \u00b6 Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC1155 Standard Minting \u00b6 You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info Example \u00b6 async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } Uploading the image to IPFS \u00b6 The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating our NFT's Metadata \u00b6 Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] } Adding Generated Metadata to IPFS \u00b6 First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT. Custom Contracts \u00b6 If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-creation","text":"","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-introduction","text":"Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here.","title":"Asset Introduction"},{"location":"ethereum/assets/creating-an-asset/#ropsten","text":"","title":"Ropsten"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link","text":"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link","text":"0x6a94aC200342AC823F909F142a65232E2f052183","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#rinkeby","text":"","title":"Rinkeby"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link_1","text":"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link_1","text":"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-types-explained","text":"","title":"Asset Types Explained"},{"location":"ethereum/assets/creating-an-asset/#erc721-erc1155","text":"With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC721 &amp; ERC1155"},{"location":"ethereum/assets/creating-an-asset/#erc721-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC721 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-721-ropsten","text":"Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 721 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc721-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info","title":"ERC721 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#erc1155-overview","text":"mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC1155 Overview"},{"location":"ethereum/assets/creating-an-asset/#erc1155-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC1155 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-1155-ropsten","text":"Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 1155 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc1155-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info","title":"ERC1155 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example_1","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#uploading-the-image-to-ipfs","text":"The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading the image to IPFS"},{"location":"ethereum/assets/creating-an-asset/#creating-our-nfts-metadata","text":"Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] }","title":"Creating our NFT's Metadata"},{"location":"ethereum/assets/creating-an-asset/#adding-generated-metadata-to-ipfs","text":"First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT.","title":"Adding Generated Metadata to IPFS"},{"location":"ethereum/assets/creating-an-asset/#custom-contracts","text":"If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Custom Contracts"},{"location":"ethereum/assets/token-factories/","text":"Token Factories \u00b6 You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/assets/token-factories/#token-factories","text":"You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/exchange/accepting-a-buy-order/","text":"Accepting a Buy Order \u00b6 To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. Example for sending matchOrders is here . matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature More about order structure can be found here - Order Structure Pay ETH for ERC721 \u00b6 You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer. Bid Orders \u00b6 A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#accepting-a-buy-order","text":"To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. Example for sending matchOrders is here . matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature More about order structure can be found here - Order Structure","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#pay-eth-for-erc721","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer.","title":"Pay ETH for ERC721"},{"location":"ethereum/exchange/accepting-a-buy-order/#bid-orders","text":"A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Bid Orders"},{"location":"ethereum/exchange/contract-wallets/","text":"Contract Wallets \u00b6 Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/contract-wallets/#contract-wallets","text":"Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/creating-a-sell-order/","text":"Creating A Sell Order \u00b6 Creating an order \u00b6 Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. Step 2. Creating signature Sell ERC721 for ETH \u00b6 You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-a-sell-order","text":"","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-an-order","text":"Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. Step 2. Creating signature","title":"Creating an order"},{"location":"ethereum/exchange/creating-a-sell-order/#sell-erc721-for-eth","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder","title":"Sell ERC721 for ETH"},{"location":"ethereum/exchange/exchange-overview/","text":"Exchange Overview \u00b6 Asset matching \u00b6 The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract. Order Structure \u00b6 Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept. Order \u00b6 Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no Asset \u00b6 Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes AssetType \u00b6 Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes Asset Types \u00b6 Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js ERC721 \u00b6 assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", } ERC1155 \u00b6 assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", } ERC20 \u00b6 assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", } ETH \u00b6 assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", }, Custom Asset Matcher \u00b6 Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint Order validation \u00b6 Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books. Order execution \u00b6 Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes. Fees \u00b6 RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Exchange Overview"},{"location":"ethereum/exchange/exchange-overview/#exchange-overview","text":"","title":"Exchange Overview"},{"location":"ethereum/exchange/exchange-overview/#asset-matching","text":"The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract.","title":"Asset matching"},{"location":"ethereum/exchange/exchange-overview/#order-structure","text":"Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept.","title":"Order Structure"},{"location":"ethereum/exchange/exchange-overview/#order","text":"Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no","title":"Order"},{"location":"ethereum/exchange/exchange-overview/#asset","text":"Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes","title":"Asset"},{"location":"ethereum/exchange/exchange-overview/#assettype","text":"Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes","title":"AssetType"},{"location":"ethereum/exchange/exchange-overview/#asset-types","text":"Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js","title":"Asset Types"},{"location":"ethereum/exchange/exchange-overview/#erc721","text":"assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", }","title":"ERC721"},{"location":"ethereum/exchange/exchange-overview/#erc1155","text":"assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", }","title":"ERC1155"},{"location":"ethereum/exchange/exchange-overview/#erc20","text":"assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", }","title":"ERC20"},{"location":"ethereum/exchange/exchange-overview/#eth","text":"assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", },","title":"ETH"},{"location":"ethereum/exchange/exchange-overview/#custom-asset-matcher","text":"Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint","title":"Custom Asset Matcher"},{"location":"ethereum/exchange/exchange-overview/#order-validation","text":"Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books.","title":"Order validation"},{"location":"ethereum/exchange/exchange-overview/#order-execution","text":"Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes.","title":"Order execution"},{"location":"ethereum/exchange/exchange-overview/#fees","text":"RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Fees"},{"location":"ethereum/exchange/order-discovery/","text":"Order Discovery \u00b6 Search orders \u00b6 Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#order-discovery","text":"","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#search-orders","text":"Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Search orders"},{"location":"ethereum/exchange/updating-cancelling-an-order/","text":"Updating/Canceling an Order \u00b6 Updating an Order \u00b6 To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one. Canceling an Order \u00b6 Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updatingcanceling-an-order","text":"","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updating-an-order","text":"To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one.","title":"Updating an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#canceling-an-order","text":"Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Canceling an Order"},{"location":"ethereum/metadata/ethereum-metadata/","text":"Ethereum Metadata \u00b6 Providing Assets Metadata allows applications to extract data for digital assets and display them in an application. URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image. tokenURI \u00b6 To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function: tokenURI in ERC-721 uri in ERC-1155 . ERC-721 /** * @dev See {IERC721Metadata-tokenURI}. */ function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = baseURI(); // If there is no base URI, return the token URI. if (bytes(base).length == 0) { return _tokenURI; } // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked). if (bytes(_tokenURI).length > 0) { return LibURI.checkPrefix(base, _tokenURI); } // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI. return string(abi.encodePacked(base, tokenId.toString())); } ERC-1155 /** * @dev See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\\{id\\}` substring with the * actual token type ID. */ function uri(uint256) external view virtual override returns (string memory) { return _uri; } The tokenURI or uri function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned. Metadata Structure \u00b6 The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155 . Example of a Metadata structure for ERC-1155 NFT: { \"name\" : \"CryptoParrot#17\" , \"description\" : \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\" , \"attributes\" : [ { \"key\" : \"/background\" , \"value\" : \"rust\" }, { \"key\" : \"/body\" , \"value\" : \"lavender down\" }, { \"key\" : \"/color\" , \"value\" : \"gray\" }, { \"key\" : \"/eye\" , \"value\" : \"small 1\" }, { \"key\" : \"/head\" , \"value\" : \"navy blue nightcap\" }, { \"key\" : \"/mouth\" , \"value\" : \"yellow 6\" } ], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/png\" , \"width\" : 999 , \"height\" : 999 } } } } Description of properties: name Name of the item description A human-readable description of the item attributes key, value These are the attributes for the item image url This is the URL to the image of the item meta This is meta-information about media. Include type, width, and height animation url This is the URL to the animation of the item meta This is meta-information about media. Include type, width, and height For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS .","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#ethereum-metadata","text":"Providing Assets Metadata allows applications to extract data for digital assets and display them in an application. URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image.","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#tokenuri","text":"To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function: tokenURI in ERC-721 uri in ERC-1155 . ERC-721 /** * @dev See {IERC721Metadata-tokenURI}. */ function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = baseURI(); // If there is no base URI, return the token URI. if (bytes(base).length == 0) { return _tokenURI; } // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked). if (bytes(_tokenURI).length > 0) { return LibURI.checkPrefix(base, _tokenURI); } // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI. return string(abi.encodePacked(base, tokenId.toString())); } ERC-1155 /** * @dev See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\\{id\\}` substring with the * actual token type ID. */ function uri(uint256) external view virtual override returns (string memory) { return _uri; } The tokenURI or uri function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned.","title":"tokenURI"},{"location":"ethereum/metadata/ethereum-metadata/#metadata-structure","text":"The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155 . Example of a Metadata structure for ERC-1155 NFT: { \"name\" : \"CryptoParrot#17\" , \"description\" : \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\" , \"attributes\" : [ { \"key\" : \"/background\" , \"value\" : \"rust\" }, { \"key\" : \"/body\" , \"value\" : \"lavender down\" }, { \"key\" : \"/color\" , \"value\" : \"gray\" }, { \"key\" : \"/eye\" , \"value\" : \"small 1\" }, { \"key\" : \"/head\" , \"value\" : \"navy blue nightcap\" }, { \"key\" : \"/mouth\" , \"value\" : \"yellow 6\" } ], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/png\" , \"width\" : 999 , \"height\" : 999 } } } } Description of properties: name Name of the item description A human-readable description of the item attributes key, value These are the attributes for the item image url This is the URL to the image of the item meta This is meta-information about media. Include type, width, and height animation url This is the URL to the animation of the item meta This is meta-information about media. Include type, width, and height For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS .","title":"Metadata Structure"},{"location":"ethereum/metadata/ipfs-example/","text":"Example of uploading & using Metadata with IPFS \u00b6 Uploading images to IPFS \u00b6 To upload images to IPFS, will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require(\"axios\"); const fs = require(\"fs\"); const FormData = require(\"form-data\"); export const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`; let data = new FormData(); data.append(\"file\", fs.createReadStream(\"./yourfile.png\")); return axios.post(url, data, { headers: { \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`, pinata_api_key: pinataApiKey, pinata_secret_api_key: pinataSecretApiKey, }, }) .then(function (response) { console.log(repsonse.IpfsHash); }) .catch(function (error) { console.log(error) }); }; Response to the request: { IpfsHash: // This is the IPFS multi-hash provided back for your content, PinSize: // This is how large (in bytes) the content you just pinned is, Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating a Metadata file for NFT \u00b6 With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\": /* NFT Name - This must be a string */, \"description\": /* Description of the NFT - This must be a string */, \"image\": /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */, \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */, \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */, // the below section is not needed. \"attributes\": [ { \"key\": /* Key name - This must be a string */, \"trait_type\": /* Trait name - This must be a string */, \"value\": /* Key Value - This must be a string */ } ] } Adding generated Metadata to IPFS \u00b6 Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require('axios'); var data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]}); var config = { method: 'post', url: 'https://api.pinata.cloud/pinning/pinFileToIPFS', headers: { 'pinata_api_key': // KEY_HERE, 'pinata_secret_api_key': // SECRET_KEY_HERE, 'Content-Type': 'application/json' }, data: data }; axios(config).then(function (response) { console.log(JSON.stringify(response.data)); }).catch(function (error) { console.log(error); }); Response example: { \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\", \"PinSize\": 290, \"Timestamp\": \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Example of uploading and using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#example-of-uploading-using-metadata-with-ipfs","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#uploading-images-to-ipfs","text":"To upload images to IPFS, will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require(\"axios\"); const fs = require(\"fs\"); const FormData = require(\"form-data\"); export const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`; let data = new FormData(); data.append(\"file\", fs.createReadStream(\"./yourfile.png\")); return axios.post(url, data, { headers: { \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`, pinata_api_key: pinataApiKey, pinata_secret_api_key: pinataSecretApiKey, }, }) .then(function (response) { console.log(repsonse.IpfsHash); }) .catch(function (error) { console.log(error) }); }; Response to the request: { IpfsHash: // This is the IPFS multi-hash provided back for your content, PinSize: // This is how large (in bytes) the content you just pinned is, Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading images to IPFS"},{"location":"ethereum/metadata/ipfs-example/#creating-a-metadata-file-for-nft","text":"With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\": /* NFT Name - This must be a string */, \"description\": /* Description of the NFT - This must be a string */, \"image\": /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */, \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */, \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */, // the below section is not needed. \"attributes\": [ { \"key\": /* Key name - This must be a string */, \"trait_type\": /* Trait name - This must be a string */, \"value\": /* Key Value - This must be a string */ } ] }","title":"Creating a Metadata file for NFT"},{"location":"ethereum/metadata/ipfs-example/#adding-generated-metadata-to-ipfs","text":"Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require('axios'); var data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]}); var config = { method: 'post', url: 'https://api.pinata.cloud/pinning/pinFileToIPFS', headers: { 'pinata_api_key': // KEY_HERE, 'pinata_secret_api_key': // SECRET_KEY_HERE, 'Content-Type': 'application/json' }, data: data }; axios(config).then(function (response) { console.log(JSON.stringify(response.data)); }).catch(function (error) { console.log(error); }); Response example: { \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\", \"PinSize\": 290, \"Timestamp\": \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Adding generated Metadata to IPFS"},{"location":"ethereum/sdk/ethereum-sdk/","text":"Ethereum SDK \u00b6 Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol. Take a look at this sample app with React for a quick start. Installation \u00b6 npm install -D @rarible/protocol-ethereum-sdk or inject package into your web page with web3 instance <script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"></script> Usage with web3.js \u00b6 Configure and create Rarible SDK object \u00b6 import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values ropsten , rinkeby , mainnet or e2e Configure Rarible SDK in browser \u00b6 const web = new Web3(ethereum) const web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web }) const env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\" const raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env) ethereum - metamask browser instance (window.ethereum) For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#ethereum-sdk","text":"Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol. Take a look at this sample app with React for a quick start.","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#installation","text":"npm install -D @rarible/protocol-ethereum-sdk or inject package into your web page with web3 instance <script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"></script>","title":"Installation"},{"location":"ethereum/sdk/ethereum-sdk/#usage-with-web3js","text":"","title":"Usage with web3.js"},{"location":"ethereum/sdk/ethereum-sdk/#configure-and-create-rarible-sdk-object","text":"import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values ropsten , rinkeby , mainnet or e2e","title":"Configure and create Rarible SDK object"},{"location":"ethereum/sdk/ethereum-sdk/#configure-rarible-sdk-in-browser","text":"const web = new Web3(ethereum) const web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web }) const env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\" const raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env) ethereum - metamask browser instance (window.ethereum) For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Configure Rarible SDK in browser"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/","text":"ExchangeV2 Matching Orders \u00b6 The main function of ExchangeV2 is matchOrders. This function takes two sides of order and attempts to match them. The matching order process can be divided into stages: Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order. Asset Matching \u2014 checks the assets from left & right order match and then extracts the matching assets. Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely. Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary. Matching order Order Validation \u00b6 Check the start/end date of the order. Check whether the receiver of this order is empty or the receiver is the same as order.taker. Check whether the order is signed by its creator or the creator of the order performs a transaction. If the creator of the order is a contract, then an ERC-1271 check is performed. Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain. Asset Matching \u00b6 The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa. makeAsset is what you sell. The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface. The sales order is the NFT that you are selling. takeAsset is what you accept in return. The purchase order is the NFT that you are buying. The sales order is what you are willing to accept. New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher. Possible improvements: Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection. Support for NFT packages. Calculating Fill and Order Execution \u00b6 The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields: maker make asset type take asset type salt Fill orders that differ only in the exchange rate are stored in one mapping slot. In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value. Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -> 100Y, and the right one is 100Y -> 5X), then the part on the left determines the exchange rate. Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed. Transfer Execution \u00b6 Transfers are made using RaribleTransferManager. It takes into account protocol commissions, royalties, etc. It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients. This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages. Possible improvements: Package support. Support for random boxes.","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#exchangev2-matching-orders","text":"The main function of ExchangeV2 is matchOrders. This function takes two sides of order and attempts to match them. The matching order process can be divided into stages: Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order. Asset Matching \u2014 checks the assets from left & right order match and then extracts the matching assets. Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely. Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary. Matching order","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#order-validation","text":"Check the start/end date of the order. Check whether the receiver of this order is empty or the receiver is the same as order.taker. Check whether the order is signed by its creator or the creator of the order performs a transaction. If the creator of the order is a contract, then an ERC-1271 check is performed. Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain.","title":"Order Validation"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#asset-matching","text":"The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa. makeAsset is what you sell. The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface. The sales order is the NFT that you are selling. takeAsset is what you accept in return. The purchase order is the NFT that you are buying. The sales order is what you are willing to accept. New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher. Possible improvements: Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection. Support for NFT packages.","title":"Asset Matching"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#calculating-fill-and-order-execution","text":"The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields: maker make asset type take asset type salt Fill orders that differ only in the exchange rate are stored in one mapping slot. In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value. Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -> 100Y, and the right one is 100Y -> 5X), then the part on the left determines the exchange rate. Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed.","title":"Calculating Fill and Order Execution"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#transfer-execution","text":"Transfers are made using RaribleTransferManager. It takes into account protocol commissions, royalties, etc. It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients. This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages. Possible improvements: Package support. Support for random boxes.","title":"Transfer Execution"},{"location":"ethereum/smart-contracts/exchangev2-overview/","text":"ExchangeV2 Overview \u00b6 ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible). To make an exchange two orders are required: Sale Order \u2014 Created by the seller. Purchase Order \u2014 Bid made by the buyer. The exchange occurs if the two orders above match. The general process of creating and executing an order is as follows: The seller confirms that the exchange contract can dispose of their assets/tokens. The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return. The seller sends the order to the indexer. The buyer sends an indexer request to get an order for a specific item or collection. The buyer creates a bid. If the order and bid are matched, an exchange takes place. If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place. The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order. Creating and executing the order See more information about: ExchangeV2 Matching Orders ExchangeV2 Sell and Bid ExchangeV2 Update and Cancel","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-overview/#exchangev2-overview","text":"ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible). To make an exchange two orders are required: Sale Order \u2014 Created by the seller. Purchase Order \u2014 Bid made by the buyer. The exchange occurs if the two orders above match. The general process of creating and executing an order is as follows: The seller confirms that the exchange contract can dispose of their assets/tokens. The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return. The seller sends the order to the indexer. The buyer sends an indexer request to get an order for a specific item or collection. The buyer creates a bid. If the order and bid are matched, an exchange takes place. If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place. The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order. Creating and executing the order See more information about: ExchangeV2 Matching Orders ExchangeV2 Sell and Bid ExchangeV2 Update and Cancel","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/","text":"ExchangeV2 Sell and Bid \u00b6 Sell Order \u00b6 To create a Sell Order, use the Ethereum SDK: Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary. Create a signature: Encrypt the order for signing . Sign the order . Send the signed order to the API. Example of creating a Sell Order in SDK. Bid \u00b6 To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2 . matchOrders function has parameters: left order left order signature right order right order signature Example of creating a Bid in SDK.","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#exchangev2-sell-and-bid","text":"","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#sell-order","text":"To create a Sell Order, use the Ethereum SDK: Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary. Create a signature: Encrypt the order for signing . Sign the order . Send the signed order to the API. Example of creating a Sell Order in SDK.","title":"Sell Order"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#bid","text":"To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2 . matchOrders function has parameters: left order left order signature right order right order signature Example of creating a Bid in SDK.","title":"Bid"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/","text":"ExchangeV2 Update and Cancel \u00b6 Update \u00b6 To update the order: Make changes. Send a request to the API (see Sell Order ). New orders check the: start, end, take, make and value fields. The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract. Cancel \u00b6 To cancel the order, call the cancellation method in the ExchangeV2 contract. function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); } An error will be returned when matching such an order. Orders makers can only call this function. It marks orders that cannot be filled.","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#exchangev2-update-and-cancel","text":"","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#update","text":"To update the order: Make changes. Send a request to the API (see Sell Order ). New orders check the: start, end, take, make and value fields. The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract.","title":"Update"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#cancel","text":"To cancel the order, call the cancellation method in the ExchangeV2 contract. function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); } An error will be returned when matching such an order. Orders makers can only call this function. It marks orders that cannot be filled.","title":"Cancel"},{"location":"ethereum/smart-contracts/fees/","text":"Fees \u00b6 RaribleTransferManager supports the following types of fees: Protocol fees \u2014 are charged on both sides of the transaction. Origin fees \u2014 set for each order. It may differ for two orders. Royalties \u2014 the author of the work will receive a part of each sale. Algorithm \u00b6 The transfer of assets takes place inside the doTransfers . The following parameters are used as arguments: LibAsset.AssetType makeMatch \u2014 AssetType on the make-side order LibAsset.AssetType takeMatch \u2014 AssetType on the take-side order LibFill.FillResult fill \u2014 values on both sides that will be passed by match LibOrder.Order leftOrder \u2014 left order data LibOrder.Order rightOrder \u2014 right order data In this method, the following actions are performed. How do we calculate the commission side of the transaction? \u00b6 Use LibFeeSide.getFeeSide . It takes as arguments assetClasses of both sides (for example, ETH and ERC20 ). LibFeeSide.getFeeSide tries to determine side to pay fees: If there is ETH on any side of the transaction, it is used. If there is no ETH, we check if there is an ERC-20 and use it. If there is no ERC-20, check if there is an ERC-1155 and use it. Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction) Transfer \u00b6 If the make-side pays fees: calling doTransfersWithFees for the make-side calling transferPayouts for the take-side If the take-side pays fees: calling doTransfersWithFees for the take-side calling transferPayouts for the make-side If the side for the payment of fees are not defined: call transferPayouts for both sides When computing the total amount of the asset: The protocol fee is added on top of the filled amount. The fee for sending the buyer's order is also added on top. If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. For more information about fees, see the page RaribleTransferManager on GitHub.","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#fees","text":"RaribleTransferManager supports the following types of fees: Protocol fees \u2014 are charged on both sides of the transaction. Origin fees \u2014 set for each order. It may differ for two orders. Royalties \u2014 the author of the work will receive a part of each sale.","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#algorithm","text":"The transfer of assets takes place inside the doTransfers . The following parameters are used as arguments: LibAsset.AssetType makeMatch \u2014 AssetType on the make-side order LibAsset.AssetType takeMatch \u2014 AssetType on the take-side order LibFill.FillResult fill \u2014 values on both sides that will be passed by match LibOrder.Order leftOrder \u2014 left order data LibOrder.Order rightOrder \u2014 right order data In this method, the following actions are performed.","title":"Algorithm"},{"location":"ethereum/smart-contracts/fees/#how-do-we-calculate-the-commission-side-of-the-transaction","text":"Use LibFeeSide.getFeeSide . It takes as arguments assetClasses of both sides (for example, ETH and ERC20 ). LibFeeSide.getFeeSide tries to determine side to pay fees: If there is ETH on any side of the transaction, it is used. If there is no ETH, we check if there is an ERC-20 and use it. If there is no ERC-20, check if there is an ERC-1155 and use it. Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction)","title":"How do we calculate the commission side of the transaction?"},{"location":"ethereum/smart-contracts/fees/#transfer","text":"If the make-side pays fees: calling doTransfersWithFees for the make-side calling transferPayouts for the take-side If the take-side pays fees: calling doTransfersWithFees for the take-side calling transferPayouts for the make-side If the side for the payment of fees are not defined: call transferPayouts for both sides When computing the total amount of the asset: The protocol fee is added on top of the filled amount. The fee for sending the buyer's order is also added on top. If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. For more information about fees, see the page RaribleTransferManager on GitHub.","title":"Transfer"},{"location":"ethereum/smart-contracts/royalties/","text":"Royalties \u00b6 Royalties V2 \u00b6 Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties ( uint256 id ) override external view returns ( LibPart . Part [] memory ) { return royalties [ id ]; } Royalties V1 \u00b6 The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value . fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here . Below you can find the code block from ExchangeV1, which handles the on-chain royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); } Examples \u00b6 Setting Up Royalties on an External Collection","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties","text":"","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties-v2","text":"Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties ( uint256 id ) override external view returns ( LibPart . Part [] memory ) { return royalties [ id ]; }","title":"Royalties V2"},{"location":"ethereum/smart-contracts/royalties/#royalties-v1","text":"The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value . fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here . Below you can find the code block from ExchangeV1, which handles the on-chain royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); }","title":"Royalties V1"},{"location":"ethereum/smart-contracts/royalties/#examples","text":"Setting Up Royalties on an External Collection","title":"Examples"},{"location":"ethereum/smart-contracts/smart-contracts/","text":"Smart Contracts Overview \u00b6 Rarible Smart Contracts for Ethereum consist of: Exchange V2 \u2014 purchase and sale of tokens Tokens, TokenFactories \u2014 tokens contracts and Token Factories RoyaltiesRegistry \u2014 embedded royalties in NFT RoyaltiesProviders \u2014 commissions getting from individual contracts TransferProxy \u2014 token exchange according of the type Staking \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues Auctions \u2014 fixed-bid auction OnChainOrders \u2014 will be added to ExchangeV2 soon Let's look closer at the following components: Exchange V2 Tokens Fees Royalties For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/smart-contracts/#smart-contracts-overview","text":"Rarible Smart Contracts for Ethereum consist of: Exchange V2 \u2014 purchase and sale of tokens Tokens, TokenFactories \u2014 tokens contracts and Token Factories RoyaltiesRegistry \u2014 embedded royalties in NFT RoyaltiesProviders \u2014 commissions getting from individual contracts TransferProxy \u2014 token exchange according of the type Staking \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues Auctions \u2014 fixed-bid auction OnChainOrders \u2014 will be added to ExchangeV2 soon Let's look closer at the following components: Exchange V2 Tokens Fees Royalties For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/tokens/","text":"Tokens \u00b6 Rarible Protocol Ethereum supports two types of tokens: ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract. ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations. You can mint both types of tokens as follows: A regular minting in a blockchain network using a contract. Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred. Users can create tokens in different smart contracts. Tokens also support saving information about Royalties and information about all creators. Token Factories \u00b6 To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page. Using Token Factories, you can create the following types of smart contracts: Public ERC-721 and ERC-1155 Private ERC-721 and ERC-1155 Token Factories create beacon proxy servers . Rarible Protocol can automatically update these contracts when all token contracts are updated. Minting \u00b6 Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Minting \u00b6 Lazy Minting is supported for ERC-721 and ERC-1155. To create Lazy Minting: Generate a token ID. Create a Lazy Minting request body that the creator must sign. The creator signs the provided data. Add signature to the request body Send the data to the API. See an example of creating Lazy Minting by using API. For more information about Lazy Minting, see SDK page. Transfer \u00b6 This function transfers the token from the sender to the new owner. Arguments: owner: Address \u2014 address of the asset owner asset: Asset \u2014 asset type The function checks the asset type and performs one of the following functions: transferErc721 transferErc1155 transferErc1155 arguments: export async function transferErc1155( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string | string[], tokenAmount: string | string[] contract: Address \u2014 contract address ERC-1155 from: Address \u2014 address of the ERC-1155 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID or token array for transfer tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer transferErc721 arguments: export async function transferErc721( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string contract: Address \u2014 contract address ERC-721 from: Address \u2014 address of the ERC-721 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID for transfer Deploy \u00b6 TODO Burn \u00b6 To Burn a token, call the function: const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), }) contract \u2014 smart contract address tokenId \u2014 token identifier","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#tokens","text":"Rarible Protocol Ethereum supports two types of tokens: ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract. ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations. You can mint both types of tokens as follows: A regular minting in a blockchain network using a contract. Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred. Users can create tokens in different smart contracts. Tokens also support saving information about Royalties and information about all creators.","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#token-factories","text":"To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page. Using Token Factories, you can create the following types of smart contracts: Public ERC-721 and ERC-1155 Private ERC-721 and ERC-1155 Token Factories create beacon proxy servers . Rarible Protocol can automatically update these contracts when all token contracts are updated.","title":"Token Factories"},{"location":"ethereum/smart-contracts/tokens/#minting","text":"Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.","title":"Minting"},{"location":"ethereum/smart-contracts/tokens/#lazy-minting","text":"Lazy Minting is supported for ERC-721 and ERC-1155. To create Lazy Minting: Generate a token ID. Create a Lazy Minting request body that the creator must sign. The creator signs the provided data. Add signature to the request body Send the data to the API. See an example of creating Lazy Minting by using API. For more information about Lazy Minting, see SDK page.","title":"Lazy Minting"},{"location":"ethereum/smart-contracts/tokens/#transfer","text":"This function transfers the token from the sender to the new owner. Arguments: owner: Address \u2014 address of the asset owner asset: Asset \u2014 asset type The function checks the asset type and performs one of the following functions: transferErc721 transferErc1155 transferErc1155 arguments: export async function transferErc1155( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string | string[], tokenAmount: string | string[] contract: Address \u2014 contract address ERC-1155 from: Address \u2014 address of the ERC-1155 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID or token array for transfer tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer transferErc721 arguments: export async function transferErc721( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string contract: Address \u2014 contract address ERC-721 from: Address \u2014 address of the ERC-721 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID for transfer","title":"Transfer"},{"location":"ethereum/smart-contracts/tokens/#deploy","text":"TODO","title":"Deploy"},{"location":"ethereum/smart-contracts/tokens/#burn","text":"To Burn a token, call the function: const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), }) contract \u2014 smart contract address tokenId \u2014 token identifier","title":"Burn"},{"location":"flow/flow-api-indexer/","text":"API and Indexer Overview \u00b6 Rarible Protocol Flow NFT Indexer is a spring boot application for indexing Flow blockchain and API for reading NFT. Architecture \u00b6 The Rarible Protocol Flow indexer consists of the following parts: Backend API \u2014 Flow API implementation Scanner \u2014 core indexing functionality To read NFT events, we need to add Subscriber (see com.rarible.flow.scanner.subscriber package) with the event's description (usually contract name and event name) and start block height. The service uses Kafka to exchange messages with other Rarible services. The service also uses MongoDB as a persistence storage. Controllers \u00b6 To create or modify NFTs and search information about them: flow-nft-item-controller flow-nft-ownership-controller flow-nft-collection-controller To create or modify orders and search information about them: flow-order-controller flow-nft-order-activity-controller flow-nft-order-item-controller order-aggregation-controller Additional controllers: flow-nft-crypto-controller For more information, see Flow Indexer and Flow OpenAPI repos on GitHub.","title":"Flow API and Indexer"},{"location":"flow/flow-api-indexer/#api-and-indexer-overview","text":"Rarible Protocol Flow NFT Indexer is a spring boot application for indexing Flow blockchain and API for reading NFT.","title":"API and Indexer Overview"},{"location":"flow/flow-api-indexer/#architecture","text":"The Rarible Protocol Flow indexer consists of the following parts: Backend API \u2014 Flow API implementation Scanner \u2014 core indexing functionality To read NFT events, we need to add Subscriber (see com.rarible.flow.scanner.subscriber package) with the event's description (usually contract name and event name) and start block height. The service uses Kafka to exchange messages with other Rarible services. The service also uses MongoDB as a persistence storage.","title":"Architecture"},{"location":"flow/flow-api-indexer/#controllers","text":"To create or modify NFTs and search information about them: flow-nft-item-controller flow-nft-ownership-controller flow-nft-collection-controller To create or modify orders and search information about them: flow-order-controller flow-nft-order-activity-controller flow-nft-order-item-controller order-aggregation-controller Additional controllers: flow-nft-crypto-controller For more information, see Flow Indexer and Flow OpenAPI repos on GitHub.","title":"Controllers"},{"location":"flow/flow-overview/","text":"Rarible Protocol Flow \u00b6 Overview \u00b6 Rarible Protocol Flow combines smart contracts for minting, exchanging tokens, APIs for order creation, discovery, standards used in smart contracts. Main features: Minting: Exchange (List, Sell/Buy): On-chain mechanics of listing and buying items. Safe removal of an item from the sale if the item has been moved or burned after being put up for sale. Multiple asset types are supported to fill orders: FT and NFT . Supported FT: FLOW FUSD FT Indexer: Provides ways to query NFT for contracts that you want to monitor. Exposes ways to create orders. Smart Contracts \u00b6 Here you can find Rarible Smart Contracts deployed instances across Flow Testnet and Mainnet. Smart Contract Mainnet Testnet RaribleNFT A.01ab36aaf654a13e.RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT A.ebf4ae01d1284af8.LicensedNFT For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub. API Reference \u00b6 Use these base URLs to access our API on different Flow networks: Base URL Network https://flow-api.rarible.com/v0.1/doc Mainnet https://flow-api-staging.rarible.com/v0.1/doc Testnet http://flow-api-dev.rarible.com/v0.1/doc Testnet For more information, see Flow Indexer and Flow OpenAPI repos on GitHub. SDK \u00b6 Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily. With the Rarible Protocol Flow SDK, you can: Authenticate customer Logout customer Make regular mint Transfer tokens Burn tokens Create sell orders Cancel sell order Buy tokens for regular sell orders Sign user message","title":"Flow Overview"},{"location":"flow/flow-overview/#rarible-protocol-flow","text":"","title":"Rarible Protocol Flow"},{"location":"flow/flow-overview/#overview","text":"Rarible Protocol Flow combines smart contracts for minting, exchanging tokens, APIs for order creation, discovery, standards used in smart contracts. Main features: Minting: Exchange (List, Sell/Buy): On-chain mechanics of listing and buying items. Safe removal of an item from the sale if the item has been moved or burned after being put up for sale. Multiple asset types are supported to fill orders: FT and NFT . Supported FT: FLOW FUSD FT Indexer: Provides ways to query NFT for contracts that you want to monitor. Exposes ways to create orders.","title":"Overview"},{"location":"flow/flow-overview/#smart-contracts","text":"Here you can find Rarible Smart Contracts deployed instances across Flow Testnet and Mainnet. Smart Contract Mainnet Testnet RaribleNFT A.01ab36aaf654a13e.RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT A.ebf4ae01d1284af8.LicensedNFT For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub.","title":"Smart Contracts"},{"location":"flow/flow-overview/#api-reference","text":"Use these base URLs to access our API on different Flow networks: Base URL Network https://flow-api.rarible.com/v0.1/doc Mainnet https://flow-api-staging.rarible.com/v0.1/doc Testnet http://flow-api-dev.rarible.com/v0.1/doc Testnet For more information, see Flow Indexer and Flow OpenAPI repos on GitHub.","title":"API Reference"},{"location":"flow/flow-overview/#sdk","text":"Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily. With the Rarible Protocol Flow SDK, you can: Authenticate customer Logout customer Make regular mint Transfer tokens Burn tokens Create sell orders Cancel sell order Buy tokens for regular sell orders Sign user message","title":"SDK"},{"location":"flow/flow-sdk/","text":"Flow SDK \u00b6 Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily. Installation \u00b6 npm i -S @rarible/flow-sdk Usage \u00b6 Configure fcl Create and use flow-sdk Configure fcl \u00b6 Flow-sdk use @onflow/fcl-js . You can find configuration details for fcl in this page //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" }) Create and use flow-sdk \u00b6 Then we create the SDK according to the network that we configured in the previous step. import { createFlowSdk } from \"@rarible/flow-sdk\" import * as fcl from \"@onflow/fcl\" const sdk = createFlowSdk ( fcl , \"testnet\" ) Minting \u00b6 Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , []) Transfer \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . transfer ( collection , tokenId , toFlowAddress ) Burn \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . burn ( collection , tokenId ) Create sell order \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , currency , tokenId , price ) // supported currencies for now \"FLOW\" and \"FUSD\" // price must be a string of flow fungible token amount with 8 decimals, for example: 1.123 or 0.1 or 0.00000001 Update order \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , currency , orderId , price ) // supported currencies for now \"FLOW\" and \"FUSD\" // price must be a string of flow fungible token amount with 8 decimals, for example: 1.123 or 0.1 or 0.00000001 Cancel order \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , orderId ) Buy an item \u00b6 const { status , statusCode , errorMessage , events , } = await sdk . nft . fill ( collection , orderId , owner ) For more information on using the Rarible Protocol Flow SDK, see the page Flow SDK on GitHub.","title":"Flow SDK"},{"location":"flow/flow-sdk/#flow-sdk","text":"Rarible Protocol Flow SDK enables applications to interact with Rarible Flow protocol easily.","title":"Flow SDK"},{"location":"flow/flow-sdk/#installation","text":"npm i -S @rarible/flow-sdk","title":"Installation"},{"location":"flow/flow-sdk/#usage","text":"Configure fcl Create and use flow-sdk","title":"Usage"},{"location":"flow/flow-sdk/#configure-fcl","text":"Flow-sdk use @onflow/fcl-js . You can find configuration details for fcl in this page //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" })","title":"Configure fcl"},{"location":"flow/flow-sdk/#create-and-use-flow-sdk","text":"Then we create the SDK according to the network that we configured in the previous step. import { createFlowSdk } from \"@rarible/flow-sdk\" import * as fcl from \"@onflow/fcl\" const sdk = createFlowSdk ( fcl , \"testnet\" )","title":"Create and use flow-sdk"},{"location":"flow/flow-sdk/#minting","text":"Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , [])","title":"Minting"},{"location":"flow/flow-sdk/#transfer","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . transfer ( collection , tokenId , toFlowAddress )","title":"Transfer"},{"location":"flow/flow-sdk/#burn","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . burn ( collection , tokenId )","title":"Burn"},{"location":"flow/flow-sdk/#create-sell-order","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , currency , tokenId , price ) // supported currencies for now \"FLOW\" and \"FUSD\" // price must be a string of flow fungible token amount with 8 decimals, for example: 1.123 or 0.1 or 0.00000001","title":"Create sell order"},{"location":"flow/flow-sdk/#update-order","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , currency , orderId , price ) // supported currencies for now \"FLOW\" and \"FUSD\" // price must be a string of flow fungible token amount with 8 decimals, for example: 1.123 or 0.1 or 0.00000001","title":"Update order"},{"location":"flow/flow-sdk/#cancel-order","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . sell ( collection , orderId )","title":"Cancel order"},{"location":"flow/flow-sdk/#buy-an-item","text":"const { status , statusCode , errorMessage , events , } = await sdk . nft . fill ( collection , orderId , owner ) For more information on using the Rarible Protocol Flow SDK, see the page Flow SDK on GitHub.","title":"Buy an item"},{"location":"flow/flow-smart-contracts/","text":"Flow Smart Contracts Overview \u00b6 Rarible Smart Contracts for Flow consist of: RaribleFee \u2014 fee manager that holds the rates and addresses fees. LicensedNFT \u2014 contract interface adds royalties to NFT. You can implement this LicensedNFT in your contract (along with NonFungibleToken ), and your royalties will be taken when trading on Rarible . RaribleNFT \u2014 Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum. RaribleOrder \u2014 marketplace contract is the wrapper for the standard NFTStorefront for handling market orders. For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub. Matching Orders \u00b6 Direct purchase of the item for sale is currently available. This means that you cannot bid on purchasing the item yet. But you can purchase an item for the amount the owner estimates the item. The purchase can be divided into several stages: Submit an item for sale Purchase of an item Listing an item for sale \u00b6 To list an item for sale, the seller has to: Select the item Indicate its cost For more information, see Rarible Protocol Flow SDK . At the moment of placing an item for sale in a smart contract, all payments are calculated and recorded. A smart contract implements such types of payments as: Commission for the sale of an item \u2014 it's 2.5% of the item's value, which the seller set. The seller pays the commission. Commission for the purchase of the item \u2014 it's 2.5% of the item's value, which the seller set. The buyer pays the commission. Royalties \u2014 are paid on the item's value as determined by the seller. Payment to the seller \u2014 the remainder of the item's value, minus the item's sale commission and royalties. Thus, the seller, putting up an item with a royalty of 10% for sale for 100 FLOW, will receive 87.5 FLOW as he pays: 2.5 FLOW commissions and 10 FLOW royalties after the sale. The buyer under the same conditions will purchase the item for 102.5 FLOW, where 2.5 FLOW will be counted as a commission. If, after placing an item for sale, the item is transferred to another user or destroyed, the smart contract will automatically remove the item from the sale. Buying an item \u00b6 The buyer needs to provide the order ID and the item owner to buy an item. During the execution of the transaction, the buyer must have sufficient funds to purchase the item. For more information, see Rarible Protocol Flow SDK . Coming soon \u00b6 Soon we will implement the following features: Put an item up for auction Place a bid on an item Accept a bid","title":"Flow Smart Contracts"},{"location":"flow/flow-smart-contracts/#flow-smart-contracts-overview","text":"Rarible Smart Contracts for Flow consist of: RaribleFee \u2014 fee manager that holds the rates and addresses fees. LicensedNFT \u2014 contract interface adds royalties to NFT. You can implement this LicensedNFT in your contract (along with NonFungibleToken ), and your royalties will be taken when trading on Rarible . RaribleNFT \u2014 Rarible NFT contract that implements the Flow NFT standard is equivalent to ERC-721 or ERC-1155 on Ethereum. RaribleOrder \u2014 marketplace contract is the wrapper for the standard NFTStorefront for handling market orders. For more information, see Rarible Protocol Flow Smart Contracts repo on GitHub.","title":"Flow Smart Contracts Overview"},{"location":"flow/flow-smart-contracts/#matching-orders","text":"Direct purchase of the item for sale is currently available. This means that you cannot bid on purchasing the item yet. But you can purchase an item for the amount the owner estimates the item. The purchase can be divided into several stages: Submit an item for sale Purchase of an item","title":"Matching Orders"},{"location":"flow/flow-smart-contracts/#listing-an-item-for-sale","text":"To list an item for sale, the seller has to: Select the item Indicate its cost For more information, see Rarible Protocol Flow SDK . At the moment of placing an item for sale in a smart contract, all payments are calculated and recorded. A smart contract implements such types of payments as: Commission for the sale of an item \u2014 it's 2.5% of the item's value, which the seller set. The seller pays the commission. Commission for the purchase of the item \u2014 it's 2.5% of the item's value, which the seller set. The buyer pays the commission. Royalties \u2014 are paid on the item's value as determined by the seller. Payment to the seller \u2014 the remainder of the item's value, minus the item's sale commission and royalties. Thus, the seller, putting up an item with a royalty of 10% for sale for 100 FLOW, will receive 87.5 FLOW as he pays: 2.5 FLOW commissions and 10 FLOW royalties after the sale. The buyer under the same conditions will purchase the item for 102.5 FLOW, where 2.5 FLOW will be counted as a commission. If, after placing an item for sale, the item is transferred to another user or destroyed, the smart contract will automatically remove the item from the sale.","title":"Listing an item for sale"},{"location":"flow/flow-smart-contracts/#buying-an-item","text":"The buyer needs to provide the order ID and the item owner to buy an item. During the execution of the transaction, the buyer must have sufficient funds to purchase the item. For more information, see Rarible Protocol Flow SDK .","title":"Buying an item"},{"location":"flow/flow-smart-contracts/#coming-soon","text":"Soon we will implement the following features: Put an item up for auction Place a bid on an item Accept a bid","title":"Coming soon"},{"location":"getting-started/community/","text":"Community and resources \u00b6 DAO \u00b6 If you're a builder or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. Github is where everything lives. Since we are open-source, many resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is where we document the current API capabilities. DAO Twitter Resources \u00b6 Rarible Youtube Rarible Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network. Submitting \u00b6 You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion Audits \u00b6 Rarible Protocol is audited. Check this report by ChainSecurity.com . License \u00b6 Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"Community and resources"},{"location":"getting-started/community/#community-and-resources","text":"","title":"Community and resources"},{"location":"getting-started/community/#dao","text":"If you're a builder or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. Github is where everything lives. Since we are open-source, many resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is where we document the current API capabilities. DAO Twitter","title":"DAO"},{"location":"getting-started/community/#resources","text":"Rarible Youtube Rarible Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network.","title":"Resources"},{"location":"getting-started/community/#submitting","text":"You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion","title":"Submitting"},{"location":"getting-started/community/#audits","text":"Rarible Protocol is audited. Check this report by ChainSecurity.com .","title":"Audits"},{"location":"getting-started/community/#license","text":"Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"License"},{"location":"getting-started/glossary/","text":"Glossary \u00b6 This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T A \u00b6 API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.). B \u00b6 Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain. C \u00b6 Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator. E \u00b6 ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations. I \u00b6 Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} . F \u00b6 Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties. L \u00b6 Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer. M \u00b6 Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. N \u00b6 NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art. O \u00b6 Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} . P \u00b6 Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created. R \u00b6 Royalties Fees that are usually paid to the creator on every sale. S \u00b6 Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted. T \u00b6 Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"Glossary"},{"location":"getting-started/glossary/#glossary","text":"This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T","title":"Glossary"},{"location":"getting-started/glossary/#a","text":"API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).","title":"A"},{"location":"getting-started/glossary/#b","text":"Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain.","title":"B"},{"location":"getting-started/glossary/#c","text":"Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator.","title":"C"},{"location":"getting-started/glossary/#e","text":"ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.","title":"E"},{"location":"getting-started/glossary/#i","text":"Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} .","title":"I"},{"location":"getting-started/glossary/#f","text":"Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.","title":"F"},{"location":"getting-started/glossary/#l","text":"Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.","title":"L"},{"location":"getting-started/glossary/#m","text":"Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain.","title":"M"},{"location":"getting-started/glossary/#n","text":"NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.","title":"N"},{"location":"getting-started/glossary/#o","text":"Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} .","title":"O"},{"location":"getting-started/glossary/#p","text":"Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created.","title":"P"},{"location":"getting-started/glossary/#r","text":"Royalties Fees that are usually paid to the creator on every sale.","title":"R"},{"location":"getting-started/glossary/#s","text":"Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted.","title":"S"},{"location":"getting-started/glossary/#t","text":"Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"T"},{"location":"getting-started/protocol-example/","text":"Example app \u00b6 Start with Rarible Protocol SDK . Also, you can create a Protocol Example App for a quick start. In this example, you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App . Example of NFT purchase flow \u00b6 Click buy NFT in the app. The frontend calls the Buy function in the Multichain SDK. Multichain SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to the Multichain service. Multichain sends the information about the event to the backend of the application. TODO Modify picture to reflect the Multichain rename. \u00b6","title":"Example app"},{"location":"getting-started/protocol-example/#example-app","text":"Start with Rarible Protocol SDK . Also, you can create a Protocol Example App for a quick start. In this example, you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App .","title":"Example app"},{"location":"getting-started/protocol-example/#example-of-nft-purchase-flow","text":"Click buy NFT in the app. The frontend calls the Buy function in the Multichain SDK. Multichain SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to the Multichain service. Multichain sends the information about the event to the backend of the application.","title":"Example of NFT purchase flow"},{"location":"getting-started/protocol-example/#todo-modify-picture-to-reflect-the-multichain-rename","text":"","title":"TODO Modify picture to reflect the Multichain rename."},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section. WIP. It's the first Quick Start version. Installation \u00b6 npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3 Usage SDK \u00b6 Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" ; import { createRaribleSdk } from \"@rarible/sdk\" ; import { EthereumWallet } from \"@rarible/sdk-wallet\" ; // Code const { ethereum } = window as any ; const web3 = new Web3 ( ethereum ); const ethWallet = new EthereumWallet ( ethereum ); const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ); In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected. See Rarible Protocol Software Development Kit repo on GitHub for more information about using SDK. Preprocessing Metadata \u00b6 Let's use the preprocess function to prepare metadata for different blockchains. const blockchain = Blockchain . ETHEREUM ; const metadata : CommonTokenMetadata = { name : \"Hey\" , description : undefined , image : undefined , animationUrl : undefined , externalUrl : undefined , attributes : [], }; const request : PreprocessMetaRequest = { blockchain , ... metadata , }; const response = sdk . nft . preprocessMeta ( request ); See Example of uploading & using Metadata with IPFS for more information about IPFS. Create Collection \u00b6 There are several collection types: collection \u2014 can mint anyone user collection \u2014 can mint only owner, need isUserToken: true You can use any public collection to mint and sell NFTs. If you want to create your collection, you have to use the deploy function in Ethereum blockchain through the Multichain SDK. ERC-1155 and ERC-721 collections look the same. const ethereum = new Web3Ethereum ({ web3 : web3 }) //user web3 instance const ethereumWallet = new EthereumWallet ( ethereum ) const sdk = createRaribleSdk ( ethereumWallet , \"staging\" ) await sdk . nft . deploy ({ blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"My own NFT collection\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , // public collection }, }, }) ERC-721 NFT Lazy Minting & Sell \u00b6 Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See ERC721-NFT Lazy Minting and List NFT on sell for more information.","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section. WIP. It's the first Quick Start version.","title":"Quick Start"},{"location":"getting-started/quick-start/#installation","text":"npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3","title":"Installation"},{"location":"getting-started/quick-start/#usage-sdk","text":"Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" ; import { createRaribleSdk } from \"@rarible/sdk\" ; import { EthereumWallet } from \"@rarible/sdk-wallet\" ; // Code const { ethereum } = window as any ; const web3 = new Web3 ( ethereum ); const ethWallet = new EthereumWallet ( ethereum ); const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ); In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected. See Rarible Protocol Software Development Kit repo on GitHub for more information about using SDK.","title":"Usage SDK"},{"location":"getting-started/quick-start/#preprocessing-metadata","text":"Let's use the preprocess function to prepare metadata for different blockchains. const blockchain = Blockchain . ETHEREUM ; const metadata : CommonTokenMetadata = { name : \"Hey\" , description : undefined , image : undefined , animationUrl : undefined , externalUrl : undefined , attributes : [], }; const request : PreprocessMetaRequest = { blockchain , ... metadata , }; const response = sdk . nft . preprocessMeta ( request ); See Example of uploading & using Metadata with IPFS for more information about IPFS.","title":"Preprocessing Metadata"},{"location":"getting-started/quick-start/#create-collection","text":"There are several collection types: collection \u2014 can mint anyone user collection \u2014 can mint only owner, need isUserToken: true You can use any public collection to mint and sell NFTs. If you want to create your collection, you have to use the deploy function in Ethereum blockchain through the Multichain SDK. ERC-1155 and ERC-721 collections look the same. const ethereum = new Web3Ethereum ({ web3 : web3 }) //user web3 instance const ethereumWallet = new EthereumWallet ( ethereum ) const sdk = createRaribleSdk ( ethereumWallet , \"staging\" ) await sdk . nft . deploy ({ blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"My own NFT collection\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , // public collection }, }, })","title":"Create Collection"},{"location":"getting-started/quick-start/#erc-721-nft-lazy-minting-sell","text":"Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See ERC721-NFT Lazy Minting and List NFT on sell for more information.","title":"ERC-721 NFT Lazy Minting &amp; Sell"},{"location":"getting-started/reasons/","text":"Why build on Rarible protocol? \u00b6 Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem. Supply and demand of the whole Rarible ecosystem \u00b6 Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible. Advanced and robust tech done for you \u00b6 Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created. Monetization \u00b6 Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations. Decentralized autonomous organization (DAO) \u00b6 Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Reasons for using protocol"},{"location":"getting-started/reasons/#why-build-on-rarible-protocol","text":"Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem.","title":"Why build on Rarible protocol?"},{"location":"getting-started/reasons/#supply-and-demand-of-the-whole-rarible-ecosystem","text":"Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible.","title":"Supply and demand of the whole Rarible ecosystem"},{"location":"getting-started/reasons/#advanced-and-robust-tech-done-for-you","text":"Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created.","title":"Advanced and robust tech done for you"},{"location":"getting-started/reasons/#monetization","text":"Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Monetization"},{"location":"getting-started/reasons/#decentralized-autonomous-organization-dao","text":"Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Decentralized autonomous organization (DAO)"},{"location":"overview/union/","text":"Rarible Protocol \u00b6 Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow Tezos Polygon (WIP, coming soon) The Rarible Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens. On top of the contracts, we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs. Then, SDKs were written to interact with smart contracts. All these components are written for every blockchain supported and are used in Multichain service and Multichain SDK . Applications need to integrate Multichain service and Multichain SDK to be able to interact with all blockchains in the same way. Protocol architecture Features \u00b6 Mint (issue, create) NFTs Trade NFTs ( sell , bid , auction ) Transfer Burn Query information about NFTs See more reasons to build on Rarible Protocol. API Reference \u00b6 We use different environments for blockchain networks. See actual information on API Reference page. SDK \u00b6 Rarible Protocol SDK enables applications to easily interact with Rarible protocol: query , issue , trade NFTs on any blockchain supported. See more information on Multichain SDK page.","title":"Overview"},{"location":"overview/union/#rarible-protocol","text":"Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow Tezos Polygon (WIP, coming soon) The Rarible Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens. On top of the contracts, we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs. Then, SDKs were written to interact with smart contracts. All these components are written for every blockchain supported and are used in Multichain service and Multichain SDK . Applications need to integrate Multichain service and Multichain SDK to be able to interact with all blockchains in the same way. Protocol architecture","title":"Rarible Protocol"},{"location":"overview/union/#features","text":"Mint (issue, create) NFTs Trade NFTs ( sell , bid , auction ) Transfer Burn Query information about NFTs See more reasons to build on Rarible Protocol.","title":"Features"},{"location":"overview/union/#api-reference","text":"We use different environments for blockchain networks. See actual information on API Reference page.","title":"API Reference"},{"location":"overview/union/#sdk","text":"Rarible Protocol SDK enables applications to easily interact with Rarible protocol: query , issue , trade NFTs on any blockchain supported. See more information on Multichain SDK page.","title":"SDK"},{"location":"resources/meetings/meeting-doc-15th-of-october/","text":"Meeting document for dev meeting on the 15th of October. Github \u00b6 https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed. Discord \u00b6 Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Meeting doc 15th of october"},{"location":"resources/meetings/meeting-doc-15th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed.","title":"Github"},{"location":"resources/meetings/meeting-doc-15th-of-october/#discord","text":"Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Discord"},{"location":"resources/meetings/meeting-doc-22nd-of-october/","text":"Meeting document for dev meeting on the 22nd of October. Github \u00b6 None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner. Discord \u00b6 Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"","title":"Meeting doc 22nd of october"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#github","text":"None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner.","title":"Github"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#discord","text":"Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"","title":"Discord"},{"location":"resources/meetings/meeting-doc-29th-of-october/","text":"Meeting document for dev meeting on the 29th of October. Github discussions: https://github.com/rarible/protocol/discussions/142 whitespace#2877 Answer: Eugene to look into it later. Meeting is too short to review there. https://github.com/rarible/protocol/discussions/11 - related to spam NFT's being minted to someone's collection Answer: We already have discussed about this. There is now a contract where only the owner can mint. We will have the possibility to deploy private contracts via the SDK, adding the feature is in our backlog. The release can be expected Monday / Tuesday next week (first week of November) Any collection that has already been released won't be able to benefit from this. Github issues: Most important: https://github.com/rarible/protocol/issues/148 owenmurovec#8687 Answer: We already fixed this in our contract. There is a PR waiting to be merged, will probably be done by Monday / Tuesday next week (first week of November) https://github.com/rarible/protocol/issues/147 Jaacob#1962 and Branko#7207 Answer: Need a TXID / Hash github issue was updated https://github.com/rarible/protocol/issues/143 tgb29#1533 Answer: Metamask should say that there is an exception in the transaction, but that isn't shown correctly. We have raised this issue to the metamask team. https://github.com/rarible/protocol-ethereum-sdk/issues/52 from inartin#9707 Answer: Need to check at another time / Please DM Eugene on TG Discord: chusla#6031 Quote: \"could we get an update on latest browser compatible sdk as well that would be much appreciated if there is any way at all to include that in next week's release for tezos etc that would unblock us thanks!\" Answer: We've got a PR open for the browser compatible SDK, we will try to move it to review within the next week. mynamebrody#5466 Quote: \"I think I'm having issues with the encodeOrder endpoint as it wants a signature but that's not required for this call yet so I haven't been including it. But adding the field with an empty value gets past this error, however, I don't think it should be there\" Answer: Will check. platocrat#4224 Quote: \"@Matt a friend just sent me this, which comes from your documentation. Is this correct? We should just fork Rarible Protocol, deploy the protocol to Polygon, then use those contracts to deploy our ERC1155 contracts?\" Just to clarify, i wish to use Rarible's contracts, which i assume to be on, Polygon to deploy our contracts \ud83d\ude42 Answer: I believe that is correct, to deploy contracts you can fork/clone the repo. What's needed to be done is to put the configuration for Polygon and deploy it to this network. But that's not everything. Rarible Protocol is not only about contracts, is about indexer and sdk as well. We have already deployed our indexer on polygon testnets but with SDK this is a bit harder because we would like to use meta transactions which means we would need to change our SDK to support these meta transactions. These are these main tasks we need to get done in order to use Polygon. We'll try it after we deploy on Tezos and Flow. Might try initial testing next week. Would be better to wait imo. idan.angel#8635 Quote: \"Hi All, I'm looking for a Rarible API that would return the assetType for any NFT listed on the marketplace. In other words, I'm looking for something like: GET ?itemId= : and I expect to get an answer that would contain a field with ERC721 or ERC1155 or Lazy_mint, something of that sort, so that I can use that value to create a new buy order. I haven't found anything of that sort. For some NFTs there are open orders which hold the assetType, but I'm looking for a standard way that would work on every NFT on Rarible, not just NFTs with open or past orders. Any help would be appreciated.\" Answer: If SDK is used, that's not needed. They just need to get an order and execute field in the SDK and the inverted order will be automatically made. If any further help is needed contact owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" Answer: creating-a-sell-order in the docs is a bit outdated, we'll fix that. Also. encodeOrder is deprecated, it's better to use SDK. Rarible docs now have a blockchain agnostic structure that isn't tied to Ethereum, there is information on how to use the SDK there. richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" Answer: Same as the answer above, please use SDK. fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\" Answer: Royalties V1 or V2 will do. Any version will be working on Polygon without a problem once we deploy there.","title":"Meeting doc 29th of october"},{"location":"resources/meetings/meeting-doc-5th-of-november/","text":"Meeting document for dev meeting on the 5th of November. Update on the 12k$ contract upgrade. When are we going to deploy that fix now that the gas fees seem to have lowered down? Update on Flow. Are we still on track to deploy between 8th and the 12nd of November? Update on the bidding function. The bid function doesn't seem to be fully supported by the SDK. What is the situation with that? (Question is related to alexon#6056 's question below) Github \u00b6 https://github.com/rarible/protocol/issues/140 - > When will the error message / html status be changed? https://github.com/rarible/protocol/issues/133 - > Has this been fixed? If not, what is an ETA for a fix. https://github.com/rarible/protocol/issues/120 - > Have we found a way to implement this? https://github.com/rarible/protocol/issues/152 - > https://github.com/rarible/protocol/issues/151 - > https://github.com/rarible/protocol-ethereum-sdk/issues/52 - > Discord \u00b6 Nick - Ownerfy#8137 Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\" Answer: Zoomer#5825 Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\" Answer: alexon#6056 Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" Answer: rimb05#3257 Quote: \"When will the 721 lazy minting minimal version be deployed?\" Answer:","title":"Meeting doc 5th of november"},{"location":"resources/meetings/meeting-doc-5th-of-november/#github","text":"https://github.com/rarible/protocol/issues/140 - > When will the error message / html status be changed? https://github.com/rarible/protocol/issues/133 - > Has this been fixed? If not, what is an ETA for a fix. https://github.com/rarible/protocol/issues/120 - > Have we found a way to implement this? https://github.com/rarible/protocol/issues/152 - > https://github.com/rarible/protocol/issues/151 - > https://github.com/rarible/protocol-ethereum-sdk/issues/52 - >","title":"Github"},{"location":"resources/meetings/meeting-doc-5th-of-november/#discord","text":"Nick - Ownerfy#8137 Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\" Answer: Zoomer#5825 Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\" Answer: alexon#6056 Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" Answer: rimb05#3257 Quote: \"When will the 721 lazy minting minimal version be deployed?\" Answer:","title":"Discord"},{"location":"resources/meetings/meeting-doc-8th-of-october/","text":"Meeting document for dev meeting on the 8th of October. Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs. \u00b6 There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting Github \u00b6 https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there. Discord \u00b6 All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Meeting doc 8th of october"},{"location":"resources/meetings/meeting-doc-8th-of-october/#addresing-the-httpsapi-stagingrariblecom-to-httpsethereum-apiraribleorg-replacement-in-the-docs","text":"There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting","title":"Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs."},{"location":"resources/meetings/meeting-doc-8th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there.","title":"Github"},{"location":"resources/meetings/meeting-doc-8th-of-october/#discord","text":"All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Discord"},{"location":"tezos/tezos-contract-addresses/","text":"Contract Addresses \u00b6 Here you can find Rarible Smart Contracts deployed instances across Tezos Mainnet and Hangzhou Net. Mainnet \u00b6 Name Address Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Hangzhou \u00b6 Name Address royalties KT1WKRXswxEpTbVg2pGgofzwZCNKjAVcuMgh transfer_proxy KT1Qypf9A7DHoAeesu5hj8v6iKwHsJb1RUR2 transfer_manager KT1DyDkW16XBuFzpLkXKraD46SAxQDrha5gm fill KT1FAndThSQsVqYQVPHGSG5sQPk1XZycNBvL exchange KT1ULGjK8FtaJ9QqCgJVN14B6tY76Ykaz6M8","title":"Contract Addresses"},{"location":"tezos/tezos-contract-addresses/#contract-addresses","text":"Here you can find Rarible Smart Contracts deployed instances across Tezos Mainnet and Hangzhou Net.","title":"Contract Addresses"},{"location":"tezos/tezos-contract-addresses/#mainnet","text":"Name Address Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC","title":"Mainnet"},{"location":"tezos/tezos-contract-addresses/#hangzhou","text":"Name Address royalties KT1WKRXswxEpTbVg2pGgofzwZCNKjAVcuMgh transfer_proxy KT1Qypf9A7DHoAeesu5hj8v6iKwHsJb1RUR2 transfer_manager KT1DyDkW16XBuFzpLkXKraD46SAxQDrha5gm fill KT1FAndThSQsVqYQVPHGSG5sQPk1XZycNBvL exchange KT1ULGjK8FtaJ9QqCgJVN14B6tY76Ykaz6M8","title":"Hangzhou"},{"location":"tezos/tezos-overview/","text":"Rarible Protocol Tezos \u00b6 Overview \u00b6 Tezos has low fees, high performance, and a smaller carbon footprint than proof-of-work blockchains as a proof-of-stake blockchain. Main features: Creating NFTs on the Tezos blockchain API server similar to the one already available for Ethereum SDK in the same model as Ethereum Using Crawlori to crawl the Tezos blockchain Support for the Tezos was built by Tezos team: Backend and SDK was built by Functori Edukera and Nomadic Labs managed the smart contracts Source code is available here . Tezos API and SDK documentation can be found here . Smart Contracts \u00b6 Tezos Exchange smart contracts it's a port of the Rarible ExchangeV2 contract. The diagram below presents the process flow between contracts: To see more details about the smart contracts as well as their code, check the Exchange Contracts and NFT Contracts on the GitLab repo. API Reference \u00b6 Use these base URL to access API on the Tezos network: Base URL Network Net https://rarible-api-mainnet.functori.com/v0.1 Tezos Mainnet https://rarible-api.functori.com/v0.1 Tezos Hangzhou Tezos API documentation can be found here . SDK \u00b6 SDK in the same model as Ethereum . It will allow interacting \"programmatically\" with the smart contract and the API server. Tezos SDK documentation can be found here . For more information on using the Rarible Protocol Tezos SDK, see the Tezos repo on GitLab.","title":"Tezos Overview"},{"location":"tezos/tezos-overview/#rarible-protocol-tezos","text":"","title":"Rarible Protocol Tezos"},{"location":"tezos/tezos-overview/#overview","text":"Tezos has low fees, high performance, and a smaller carbon footprint than proof-of-work blockchains as a proof-of-stake blockchain. Main features: Creating NFTs on the Tezos blockchain API server similar to the one already available for Ethereum SDK in the same model as Ethereum Using Crawlori to crawl the Tezos blockchain Support for the Tezos was built by Tezos team: Backend and SDK was built by Functori Edukera and Nomadic Labs managed the smart contracts Source code is available here . Tezos API and SDK documentation can be found here .","title":"Overview"},{"location":"tezos/tezos-overview/#smart-contracts","text":"Tezos Exchange smart contracts it's a port of the Rarible ExchangeV2 contract. The diagram below presents the process flow between contracts: To see more details about the smart contracts as well as their code, check the Exchange Contracts and NFT Contracts on the GitLab repo.","title":"Smart Contracts"},{"location":"tezos/tezos-overview/#api-reference","text":"Use these base URL to access API on the Tezos network: Base URL Network Net https://rarible-api-mainnet.functori.com/v0.1 Tezos Mainnet https://rarible-api.functori.com/v0.1 Tezos Hangzhou Tezos API documentation can be found here .","title":"API Reference"},{"location":"tezos/tezos-overview/#sdk","text":"SDK in the same model as Ethereum . It will allow interacting \"programmatically\" with the smart contract and the API server. Tezos SDK documentation can be found here . For more information on using the Rarible Protocol Tezos SDK, see the Tezos repo on GitLab.","title":"SDK"},{"location":"union-sdk/api/","text":"API Usage with SDK \u00b6 You can find all available endpoints on API Reference page. API is pretty easy when it comes to SDK, you can use it with SDK like this: const response = await sdk . apis . order . ( function you want to invoke ) The most important thing is to remember that there are different endpoints for different environments when it comes to the API. While changing environments, you would need to change endpoints accordingly because different APIs function in other chains. E.g., there're different endpoints for Rinkeby than for Ropsten. SDK is taking full care of managing that. Mainnet environments: eth: mainnet tezos: mainnet flow: mainnet solana: mainnet Testnet environments: eth: rinkeby tezos: hangzhou flow: devnet solana: testnet The best documentation here is to explore SDK by holding CTRL / CMD and the left button to see the available endpoints and needed parameters.","title":"API Usage with SDK"},{"location":"union-sdk/api/#api-usage-with-sdk","text":"You can find all available endpoints on API Reference page. API is pretty easy when it comes to SDK, you can use it with SDK like this: const response = await sdk . apis . order . ( function you want to invoke ) The most important thing is to remember that there are different endpoints for different environments when it comes to the API. While changing environments, you would need to change endpoints accordingly because different APIs function in other chains. E.g., there're different endpoints for Rinkeby than for Ropsten. SDK is taking full care of managing that. Mainnet environments: eth: mainnet tezos: mainnet flow: mainnet solana: mainnet Testnet environments: eth: rinkeby tezos: hangzhou flow: devnet solana: testnet The best documentation here is to explore SDK by holding CTRL / CMD and the left button to see the available endpoints and needed parameters.","title":"API Usage with SDK"},{"location":"union-sdk/nft/","text":"Transfer, Mint, Burn \u00b6 Transfer, minting, and burning are the primary operations we can invoke on the blockchain. Below you can find a \"how to use it\" description. ERC721-NFT Lazy Minting \u00b6 To lazy mint an item following parameters are required: URI \u2014 address of data on IPFS supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) lazyMint \u2014 boolean, if we want to mint it lazily or normally creators \u2014 the array of creators, which allows distributing profits from sell in accordance to defined criteria royalties \u2014 the array of royalties, which allows taking a defined amount of any consecutive sell Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 // Examplary values of URI and supply const [ uri , setUri ] = useState < string > ( \"ipfs:/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" ); const [ supply , setSupply ] = useState < number > ( 1 ); const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // 1. Create PrepareMintRequest // Collection ids are the address of Rarible Smart Contracts instance // You can find them here: // https://docs.rarible.org/ethereum/contract-addresses/ const mintRequest : PrepareMintRequest = { // Using Rarible API, tokenId would also be needed, but SDK takes care for that collectionId : toContractAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), }; // 2. Get Mint Response // From mintResponse you can extract additional info e.g. is supply > 1 enabled const mintResponse = await sdk . nft . mint ( mintRequest ); // If you want to divide profits here, you can add more than one creator object // Combined value amount has to be 10000, which equals to 100 %, same with royalties const creators = [ { account : `ETHEREUM: ${ makerAccount } ` , value : 10000 , }, ]; const royalties = []; // 3. Submit Mint Response const submitResponse = await mintResponse . submit ({ uri , supply , lazyMint : true , // Lazy Mint is not always available, you can check it in mint response created in step 2 creators , royalties , }); // Example of successful response // itemId: \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" // type: \"off-chain\" ERC721-NFT Lazy Mint & Sell \u00b6 Often you want to list your nft on the sale right after creation. If it's the case for you, you can also use the mintAndSell function, which allows you to do exactly that. // We can get user account in that way, or just extract it from accounts // which we saved with Metamask const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toMultichianAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId Transfer NFT Token \u00b6 If we want to transfer NFT Token from one wallet address to another, it is simple. Of course, if you want to submit a transfer transaction, you have to be the owner of an NFT. You will need: itemId transferRequest: PrepareTransferRequest const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), }; const transferResponse = await sdk . nft . transfer ( transferRequest ); const response = await transferResponse . submit ({ to : toMultichianAddress ( \"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\" ), }); Burning tokens \ud83d\udd25 \u00b6 Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Using SDK, you can do that as follows: const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const burnRequest : PrepareBurnRequest = { itemId : toItemId ( itemId ), }; const burnResponse = await sdk . nft . burn ( burnRequest ); const response = await burnResponse . submit (); Generate Token ID Request \u00b6 This is not a mandatory step because while using the mint or mintAndSell function, it's automatically done underneath, but it can be useful while using API. Because of lazy minting specification, Rarible generates token id to store it off-chain until the token is actually minted. const genTokenIdReq : GenerateTokenIdRequest = { collection : toMultichianAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), minter : toMultichianAddress ( \"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\" ), }; const tokenIdResponse = await sdk . nft . generateTokenId ( genTokenIdReq ); Preprocessing Metadata \u00b6 We use preprocessing to prepare metadata for different blockchains (eth, flow, tezos, etc.). const blockchain = Blockchain . ETHEREUM ; const metadata : CommonTokenMetadata = { name : \"Hey\" , description : undefined , image : undefined , animationUrl : undefined , externalUrl : undefined , attributes : [], }; const request : PreprocessMetaRequest = { blockchain , ... metadata , }; const response = sdk . nft . preprocessMeta ( request ); See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Transfer, Mint, Burn"},{"location":"union-sdk/nft/#transfer-mint-burn","text":"Transfer, minting, and burning are the primary operations we can invoke on the blockchain. Below you can find a \"how to use it\" description.","title":"Transfer, Mint, Burn"},{"location":"union-sdk/nft/#erc721-nft-lazy-minting","text":"To lazy mint an item following parameters are required: URI \u2014 address of data on IPFS supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) lazyMint \u2014 boolean, if we want to mint it lazily or normally creators \u2014 the array of creators, which allows distributing profits from sell in accordance to defined criteria royalties \u2014 the array of royalties, which allows taking a defined amount of any consecutive sell Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 // Examplary values of URI and supply const [ uri , setUri ] = useState < string > ( \"ipfs:/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" ); const [ supply , setSupply ] = useState < number > ( 1 ); const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // 1. Create PrepareMintRequest // Collection ids are the address of Rarible Smart Contracts instance // You can find them here: // https://docs.rarible.org/ethereum/contract-addresses/ const mintRequest : PrepareMintRequest = { // Using Rarible API, tokenId would also be needed, but SDK takes care for that collectionId : toContractAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), }; // 2. Get Mint Response // From mintResponse you can extract additional info e.g. is supply > 1 enabled const mintResponse = await sdk . nft . mint ( mintRequest ); // If you want to divide profits here, you can add more than one creator object // Combined value amount has to be 10000, which equals to 100 %, same with royalties const creators = [ { account : `ETHEREUM: ${ makerAccount } ` , value : 10000 , }, ]; const royalties = []; // 3. Submit Mint Response const submitResponse = await mintResponse . submit ({ uri , supply , lazyMint : true , // Lazy Mint is not always available, you can check it in mint response created in step 2 creators , royalties , }); // Example of successful response // itemId: \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" // type: \"off-chain\"","title":"ERC721-NFT Lazy Minting"},{"location":"union-sdk/nft/#erc721-nft-lazy-mint-sell","text":"Often you want to list your nft on the sale right after creation. If it's the case for you, you can also use the mintAndSell function, which allows you to do exactly that. // We can get user account in that way, or just extract it from accounts // which we saved with Metamask const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toMultichianAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId","title":"ERC721-NFT Lazy Mint &amp; Sell"},{"location":"union-sdk/nft/#transfer-nft-token","text":"If we want to transfer NFT Token from one wallet address to another, it is simple. Of course, if you want to submit a transfer transaction, you have to be the owner of an NFT. You will need: itemId transferRequest: PrepareTransferRequest const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), }; const transferResponse = await sdk . nft . transfer ( transferRequest ); const response = await transferResponse . submit ({ to : toMultichianAddress ( \"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\" ), });","title":"Transfer NFT Token"},{"location":"union-sdk/nft/#burning-tokens","text":"Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Using SDK, you can do that as follows: const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const burnRequest : PrepareBurnRequest = { itemId : toItemId ( itemId ), }; const burnResponse = await sdk . nft . burn ( burnRequest ); const response = await burnResponse . submit ();","title":"Burning tokens \ud83d\udd25"},{"location":"union-sdk/nft/#generate-token-id-request","text":"This is not a mandatory step because while using the mint or mintAndSell function, it's automatically done underneath, but it can be useful while using API. Because of lazy minting specification, Rarible generates token id to store it off-chain until the token is actually minted. const genTokenIdReq : GenerateTokenIdRequest = { collection : toMultichianAddress ( \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" ), minter : toMultichianAddress ( \"ETHEREUM:0x79Ea2d536b5b7144A3EabdC6A7E43130199291c0\" ), }; const tokenIdResponse = await sdk . nft . generateTokenId ( genTokenIdReq );","title":"Generate Token ID Request"},{"location":"union-sdk/nft/#preprocessing-metadata","text":"We use preprocessing to prepare metadata for different blockchains (eth, flow, tezos, etc.). const blockchain = Blockchain . ETHEREUM ; const metadata : CommonTokenMetadata = { name : \"Hey\" , description : undefined , image : undefined , animationUrl : undefined , externalUrl : undefined , attributes : [], }; const request : PreprocessMetaRequest = { blockchain , ... metadata , }; const response = sdk . nft . preprocessMeta ( request ); See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Preprocessing Metadata"},{"location":"union-sdk/order/","text":"Sell, Fill, Bid \u00b6 When you have your NFT created, there is a high chance that you will want to sell it. Or try at least. The same way somebody may like your NFT, which is currently not for sale and create a bid for that. In this chapter, you can find cookbooks for all of that functionality. List NFT on sell \u00b6 To list your NFT on sell, you'll need a token address, the one you get back from await mintResponse . submit (); If you want to create a sell order immediately after lazy minting your token, you can use the mintAndSell function. It's pretty straightforward. All we need is: tokenMultichainAddress: \u2014 string in BLOCKCHAIN:CONTRACT_ADDRESS:TOKEN_ID format, see code for example price: number \u2014 price in ETH for which we want to list the token (disclaimer: it's not in wei, it's in ETH, so 0.5 equals 0.5 ETH) amount: number \u2014 quantity of NFT we want to list. In case of ERC721 it's 1 currency \u2014 type of currency: FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType etc. you can find all supported currencies @rarible/api-client/build/models/AssetType in node modules // 1. Examplary values const tokenMultichainAddress : string = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const ethCurrency : EthEthereumAssetType = { \"@type\" : \"ETH\" , }; const price : number = 1 ; const amount : number = 1 ; // 2. Create PreapreOrderRequest type object and pass it to sdk.order.sell const orderRequest : PrepareOrderRequest = { itemId : toItemId ( tokenMultichainAddress ), }; // You can extract info about properties from orderResponse e.g. // 1. Base fee // 2. Max Amount // etc. const orderResponse = await sdk . order . sell ( orderRequest ); // 3. Submit the transaction -> it will pop up the metamask asking you to sign a transaction const response = await orderResponse . submit ({ price , amount , currency : ethCurrency , }); // We get order id from the response. It can be useful when we want to update sell order Update listed token price \u00b6 To update the listed token price, you need a sell order id. Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. const price : number = 0.8 ; const ethCurrency : EthEthereumAssetType = { \"@type\" : \"ETH\" , }; const orderId = \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\" ; const updateOrderRequest : PrepareOrderUpdateRequest = { orderId : toOrderId ( orderId ), }; const updateResponse = await sdk . order . sellUpdate ( updateOrderRequest ); const response = await updateResponse . submit ({ price , }); Fill sell order \u00b6 Filling a sell order can be compared to paying for an object in a physical store. The sell order is the object being displayed, and filling would represent taking it to the cash register and paying for it. In order to fill up a sell order, the only required data is orderId. const orderId : string = \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ); }; const fillResponse = await sdk . order . fill ( fillRequest ); const response = await fillResponse . submit ({ amount : 1 // Number of NFTs to buy }) Create a bid \u00b6 If filling a sell order can be compared with taking something to the cash register and paying for it, bidding can be compared to seeing something you want, going up to the owner, and saying, \"Hey, I want that, here's my offer.\" In practice, it works in the same way. You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. You will need: tokenMultichainAddress currency \u2014 type of currency: FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType etc. you can find all supported currencies @rarible/api-client/build/models/AssetType in node modules price amount The contract in ethCurrency is NOT an ERC721 address which you can find here . It's a WETH address. For different chains, they are as follow: Mainnet: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 Rinkeby / Ropsten: 0xc778417e063141139fce010982780140aa0cd5ab const tokenMultichainAddress = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const currency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( // WETH address on Rinkeby/Ropsten testnets \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\" ), }; const price : number = 1 ; const amount : number = 1 ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( tokenMultichainAddress ), }; const bidResponse = await sdk . order . bid ( orderRequest ); const response = await bidResponse . submit ({ amount , price , currency , }); Update a bid \u00b6 Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. You will need: bidOrderId \u2014 you can obtain it from bidResponse.submit price updateBidRequest: PrepareOrderUpdateRequest const bidOrderId = \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\" ; const price : number = 2 ; const updateBidRequest : PrepareOrderUpdateRequest = { orderId : toOrderId ( bidOrderId ), }; const updateResponse = await sdk . order . bidUpdate ( updateBidRequest ); const response = await updateResponse . submit ({ price , }); Cancel a bid \u00b6 In order to cancel a bid, you need an orderId . const bidOrderId = \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\" ; const cancelOrderRequest : CancelOrderRequest = { orderId : toOrderId ( bidOrderId ), }; const cancelResponse = await sdk . order . cancel ( cancelOrderRequest ); See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Sell, Bid, Fill"},{"location":"union-sdk/order/#sell-fill-bid","text":"When you have your NFT created, there is a high chance that you will want to sell it. Or try at least. The same way somebody may like your NFT, which is currently not for sale and create a bid for that. In this chapter, you can find cookbooks for all of that functionality.","title":"Sell, Fill, Bid"},{"location":"union-sdk/order/#list-nft-on-sell","text":"To list your NFT on sell, you'll need a token address, the one you get back from await mintResponse . submit (); If you want to create a sell order immediately after lazy minting your token, you can use the mintAndSell function. It's pretty straightforward. All we need is: tokenMultichainAddress: \u2014 string in BLOCKCHAIN:CONTRACT_ADDRESS:TOKEN_ID format, see code for example price: number \u2014 price in ETH for which we want to list the token (disclaimer: it's not in wei, it's in ETH, so 0.5 equals 0.5 ETH) amount: number \u2014 quantity of NFT we want to list. In case of ERC721 it's 1 currency \u2014 type of currency: FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType etc. you can find all supported currencies @rarible/api-client/build/models/AssetType in node modules // 1. Examplary values const tokenMultichainAddress : string = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const ethCurrency : EthEthereumAssetType = { \"@type\" : \"ETH\" , }; const price : number = 1 ; const amount : number = 1 ; // 2. Create PreapreOrderRequest type object and pass it to sdk.order.sell const orderRequest : PrepareOrderRequest = { itemId : toItemId ( tokenMultichainAddress ), }; // You can extract info about properties from orderResponse e.g. // 1. Base fee // 2. Max Amount // etc. const orderResponse = await sdk . order . sell ( orderRequest ); // 3. Submit the transaction -> it will pop up the metamask asking you to sign a transaction const response = await orderResponse . submit ({ price , amount , currency : ethCurrency , }); // We get order id from the response. It can be useful when we want to update sell order","title":"List NFT on sell"},{"location":"union-sdk/order/#update-listed-token-price","text":"To update the listed token price, you need a sell order id. Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. const price : number = 0.8 ; const ethCurrency : EthEthereumAssetType = { \"@type\" : \"ETH\" , }; const orderId = \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\" ; const updateOrderRequest : PrepareOrderUpdateRequest = { orderId : toOrderId ( orderId ), }; const updateResponse = await sdk . order . sellUpdate ( updateOrderRequest ); const response = await updateResponse . submit ({ price , });","title":"Update listed token price"},{"location":"union-sdk/order/#fill-sell-order","text":"Filling a sell order can be compared to paying for an object in a physical store. The sell order is the object being displayed, and filling would represent taking it to the cash register and paying for it. In order to fill up a sell order, the only required data is orderId. const orderId : string = \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ); }; const fillResponse = await sdk . order . fill ( fillRequest ); const response = await fillResponse . submit ({ amount : 1 // Number of NFTs to buy })","title":"Fill sell order"},{"location":"union-sdk/order/#create-a-bid","text":"If filling a sell order can be compared with taking something to the cash register and paying for it, bidding can be compared to seeing something you want, going up to the owner, and saying, \"Hey, I want that, here's my offer.\" In practice, it works in the same way. You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. You will need: tokenMultichainAddress currency \u2014 type of currency: FlowAssetTypeNft | TezosXTZAssetType | EthErc20AssetType etc. you can find all supported currencies @rarible/api-client/build/models/AssetType in node modules price amount The contract in ethCurrency is NOT an ERC721 address which you can find here . It's a WETH address. For different chains, they are as follow: Mainnet: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 Rinkeby / Ropsten: 0xc778417e063141139fce010982780140aa0cd5ab const tokenMultichainAddress = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\" ; const currency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( // WETH address on Rinkeby/Ropsten testnets \"ETHEREUM:0xc778417e063141139fce010982780140aa0cd5ab\" ), }; const price : number = 1 ; const amount : number = 1 ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( tokenMultichainAddress ), }; const bidResponse = await sdk . order . bid ( orderRequest ); const response = await bidResponse . submit ({ amount , price , currency , });","title":"Create a bid"},{"location":"union-sdk/order/#update-a-bid","text":"Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. You will need: bidOrderId \u2014 you can obtain it from bidResponse.submit price updateBidRequest: PrepareOrderUpdateRequest const bidOrderId = \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\" ; const price : number = 2 ; const updateBidRequest : PrepareOrderUpdateRequest = { orderId : toOrderId ( bidOrderId ), }; const updateResponse = await sdk . order . bidUpdate ( updateBidRequest ); const response = await updateResponse . submit ({ price , });","title":"Update a bid"},{"location":"union-sdk/order/#cancel-a-bid","text":"In order to cancel a bid, you need an orderId . const bidOrderId = \"ETHEREUM:0x27b554bdf22fe72e89f113e9523e8d8a75fb4477d455e100dc2bb132e7f51682\" ; const cancelOrderRequest : CancelOrderRequest = { orderId : toOrderId ( bidOrderId ), }; const cancelResponse = await sdk . order . cancel ( cancelOrderRequest ); See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Cancel a bid"},{"location":"use-cases/bubblesdk/","text":"Rarible SDK No-Code plugin \u00b6 This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside. API supported features: \u00b6 Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection SDK supported features: \u00b6 ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here . How to use: \u00b6 Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"EZCode SDK plugin"},{"location":"use-cases/bubblesdk/#rarible-sdk-no-code-plugin","text":"This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside.","title":"Rarible SDK No-Code plugin"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here .","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"How to use:"},{"location":"use-cases/coconft/","text":"cocoNFT \u00b6 TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/coconft/#coconft","text":"TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"MintGate \u00b6 TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/mintgate/#mintgate","text":"TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/moralisplugin/","text":"Moralis Rarible Plugin \u00b6 This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it. Supported chains \u00b6 This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019) Supported tokens \u00b6 ERC721 ERC1155 SDK \u00b6 Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script > Lazy mint \u00b6 You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional }) Sell order \u00b6 You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , }); ERC20 \u00b6 You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"Moralis Lazy Mint & Sell plugin"},{"location":"use-cases/moralisplugin/#moralis-rarible-plugin","text":"This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it.","title":"Moralis Rarible Plugin"},{"location":"use-cases/moralisplugin/#supported-chains","text":"This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019)","title":"Supported chains"},{"location":"use-cases/moralisplugin/#supported-tokens","text":"ERC721 ERC1155","title":"Supported tokens"},{"location":"use-cases/moralisplugin/#sdk","text":"Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script >","title":"SDK"},{"location":"use-cases/moralisplugin/#lazy-mint","text":"You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional })","title":"Lazy mint"},{"location":"use-cases/moralisplugin/#sell-order","text":"You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , });","title":"Sell order"},{"location":"use-cases/moralisplugin/#erc20","text":"You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"ERC20"},{"location":"use-cases/picnic/","text":"Picnic \u00b6 We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data. API Calls \u00b6 The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org Getting Tokens by Owner \u00b6 Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Picnic"},{"location":"use-cases/picnic/#picnic","text":"We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data.","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Getting Tokens by Owner"},{"location":"use-cases/royalties-on-a-external-collection/","text":"Setting Up Royalties on an External Collection \u00b6 Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"use-cases/royalties-on-a-external-collection/#setting-up-royalties-on-an-external-collection","text":"Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"}]}